
# Function to load the input data, i.e., the files needed to build the networks
# INPUTS:
#  peakListF     - path to the TSV file that contains the peak list (one peak
#                  per row) in a MetaboLights-like format. The first row is the
#                  header (i.e., the list of columns' names). The file should
#                  contain at least 3 columns: "database_identifier" (ChEBI),
#                  "mass_to_charge", and "retention_time". It is to note that
#                  these column names are fixed. The TSV file can also contain
#                  intensity (or abundance) values. In this case, the column
#                  names are free (e.g., can be named after the samples), but
#                  no blank spaces are allowed and the first character must be
#                  a letter. In addition, all the abundances must be placed at
#                  the end of the table, i.e., in the last columns
#  intCol        - number of the first column containing the intensities or of
#                  the subset of columns to take the intensity values from. The
#                  default value is 23, as in all datasets available in
#                  MetaboLights (https://www.ebi.ac.uk/metabolights)
#  transF        - (optional) path to the CSV file containing the
#                  transformation list. It must contain at  least the columns
#                  "name", "formula", and "mass". This file is needed if the
#                  mass difference network is to be built
#  spectraF      - (optional) path to the MSMS data in MGF format, if available
#  gsmnF         - path to the compound graph in GML format, as generated by
#                  Met4J (https://forgemia.inra.fr/metexplore/met4j). The
#                  compound graphs of some organisms are available in the data
#                  folder
#  spectraSS     - (optional) samples the spectra dataset, according to the
#                  given sample size. This would speed up the process and it
#                  is useful when testing your data and/or this package
#  resPath       - path to the folder where the results will be stored
#  met2NetDir    - path to the directory where the Python package
#                  Metabolomics2Network is
#  configF       - path to the file that contains the column names
#                  (i.e., alias) of the idenMetF file and the information
#                  they contain, such as name, chebi, formula, etc. See an
#                  example in
#                  extdata/MTBLS1586/Metabolomics2NetworksData/JsonConf.txt.
#                  NOTE. This information will be used to do the metabolite
#                  mapping to the GSMN (using metabolomics2Network)
#  idenMetF     - path to the TSV file that contains the list of experimental
#                  features that were identified and that have a CHEBI id
#                  associated. The header of this file must match the aliases
#                  from the configuration file (configF)
#  compF         - path to the TSV file containing the list of compounds in the
#                  GSMN of the organism of interest. They must contain at least
#                  two columns: ID and Chebi. An example can be found in
#                  extdata/MTBLS1586/Metabolomics2NetworksData/WormJamMet.tsv
# OUTPUT: named list containing all the data (peakList, spectra,
#         transformations, and gsmn)
#' @name loadInputData
#'
#' @aliases loadInputData
#'
#' @title Load the input data
#'
#' @description
#' The function `loadInputData` loads the input data, i.e., the files needed
#' to build the networks
#'
#' @param peakListF
#' `Path`, path to the TSV file that contains the peak list (one peak per row)
#' in a MetaboLights-like format. The first row is the header (i.e., the list
#' of columns' names). The file should contain at least 3 columns:
#' "database_identifier" (ChEBI), "mass_to_charge", and "retention_time". It is
#' to note that these column names are fixed. The TSV file can also contain
#' intensity (or abundance) values. In this case, the column names are free
#' (e.g., can be named after the samples), but no blank spaces are allowed and
#' the first character must be a letter. In addition, all the abundances must
#' be placed at the end of the table, i.e., in the last columns
#'
#' @param intCol
#' `numeric`, number of the first column containing the intensities or of the
#' subset of columns to take the intensity values from. The default value is
#' 23, as in all datasets available in MetaboLights
#' (https://www.ebi.ac.uk/metabolights)
#'
#' @param transF
#' `path`, (optional) path to the CSV file containing the transformation list.
#' It must contain at  least the columns: "name", "formula", and "mass". This
#' file is needed if the mass difference network is to be built
#'
#' @param spectraF
#' `path`, (optional) path to the MSMS data in MGF format, if available
#'
#' @param gsmnF
#' `path`, path to the compound graph in GML format, as generated by Met4J
#' (https://forgemia.inra.fr/metexplore/met4j). The compound graphs of some
#' organisms are available in the data folder
#'
#' @param spectraSS
#' `numeric`, (optional) samples the spectra dataset, according to the given
#' sample size. This would speed up the process and it is useful when testing
#' your data and/or this package
#'
#' @param resPath
#' `path`, path to the folder where the results will be stored
#'
#' @param met2NetDir
#' `path`, path to the directory where the Python package Metabolomics2Network
#' is stored
#'
#' @param configF
#' `path`, path to the file that contains the column names (i.e., alias) of the
#' idenMetF file and the information they contain, such as name, chebi,
#' formula, etc. See an example in
#' extdata/MTBLS1586/Metabolomics2NetworksData/JsonConf.txt.
#' NOTE. This information will be used to do the metabolite mapping to the GSMN
#' (using metabolomics2Network)
#'
#' @param idenMetF
#' `path`, path to the TSV file that contains the list of experimental features
#' that were identified and that have a CHEBI id associated. The header of this
#' file must match the aliases from the configuration file (configF)
#'
#' @param compF
#' `path`, path to the TSV file containing the list of compounds in the GSMN of
#' the organism of interest. They must contain at least two columns: ID and
#' Chebi. An example can be found in
#' extdata/MTBLS1586/Metabolomics2NetworksData/WormJamMet.tsv
#'
#' @import igraph Spectra
#'
#' @importFrom readr read_tsv read_csv
#' @importFrom MsBackendMgf MsBackendMgf
#'
#' @return
#' Named list containing all the data (peakList, spectra, transformations, and
#' gsmn)
#'
#' @author Elva Novoa, \email{elva-maria.novoa-del-toro@@inrae.fr}
#'
#' @examples
#' # See the MultiLayerNetwork vignette
#'
#' @export
loadInputData <- function(peakListF, intCol = 23, transF, spectraF, gsmnF,
  spectraSS = NULL, resPath, met2NetDir, configF, idenMetF, compF) {

  # read peak list
  peakList <- readMaf(peakListF, ecol = intCol)
  data <- readr::read_tsv(peakListF) # read peak list file

  # keep only identified metabolites
  identifiedMet <-
    data[!is.na(data$database_identifier), c("id", "database_identifier")]

  # check if there is a fragmentation spectra file
  if (exists("spectraF")) {
    # read fragmentation spectra
    spectra <-
      Spectra::Spectra(
        spectraF,
        source = MsBackendMgf::MsBackendMgf(),
        backend = Spectra::MsBackendDataFrame()
      )

    # check if sampling is to be done
    if (!is.null(spectraSS)) {

      # check if sample size < current spectra size
      if (spectraSS < length(spectra)) {

        # sample the fragmentation spectra
        keep <- sample(seq_len(length(spectra)), spectraSS)
        spectra <- spectra[keep]
      }
    }

    # sanity check
    if (!checkSpectra(spectra)) {
      stop(paste0("Bad spectra. Please check your file ", spectra))
    }
  } else {
    spectra <- NULL
  }


  # check if there is a transformations file
  if (exists("transF")) {
    # read transformations
    transformations <- readr::read_csv(transF, col_names = TRUE)
  } else {
    transformations <- NULL
  }

  # read GSMN
  gsmn <- igraph::read_graph(gsmnF, format = "gml")

  ############################################################# TO REMOVE ????
  # remove compartments from the label of the nodes
  labels <-
    unlist(
      lapply(igraph::get.vertex.attribute(gsmn, "label"), function(X) {
        n <- nchar(X)
        substr(X, 1, n-2)
      }
      )
    )
  # set the name of the metabolites
  gsmn <- igraph::set.vertex.attribute(gsmn, name = "name", value = labels)
  ############################################################# TO REMOVE ????

  # sanity check
  if (!checkQFeatures(peakList)) {
    stop(paste0("Bad peak list. Please check your file ", peakListF))
  } else {
    # if the sanity checks are OK, return the read data
    return (
      list(
        peakList = peakList,
        allComp = data$id,
        identifiedMet = identifiedMet,
        spectra = spectra,
        transformations = transformations,
        gsmn = gsmn,
        resPath = resPath,
        configF = configF,
        idenMetF = idenMetF,
        compF = compF,
        met2NetDir = met2NetDir
        )
      )
  }
}


# Function to build experimental networks, based on spectral similarity,
# correlation, and mass difference
# INPUTS:
#  inputData - list returned by the loadInputData function
#  net2Build - list of experimental networks to build, according to the
#              following options:
#               "all" - generates 3 experimental networks: mass difference,
#                     correlation, and spectral similarity,
#               "m" - builds the mass difference network,
#               "s" - builds the spectral similarity network,
#               "c" - builds the correlation network.
#              It is to note that combinations of m, s, and c are possible,
#              writing them separated by commas, e.g., c("m", "c") would
#              generate the mass difference and correlation networks. The
#              default value is "all"
#  directed  - boolean value (TRUE/FALSE). If TRUE then the networks that are
#              generated will be directed, and undirected otherwise. The
#              default value is FALSE (i.e., undirected network)
#  ppmMass   - allowed error for mass differences calculus. It is only needed
#              if the mass difference network is to be built. The default value
#              is 10
#  ppmSpec   - relative allowed error for spectral similarity calculus. It is
#              only needed if the spectral similarity network is to be built.
#              The default value is 0
#  tol       - absolute tolerance for spectral similarity calculus. It is only
#              needed if the spectral similarity network is to be built. The
#              default value is 0.005
#  corrModel - character vector containing the model(s) to be used for the
#              correlation calculus. Please check the available models in the
#              current version of MetNet. There are 10 models available in
#              version 1.14.0: "lasso", "randomForest", "clr", "aracne",
#              "pearson", "pearson_partial", "spearman", "spearman_partial",
#              "ggm", and "bayes". This parameter is only needed if the
#              correlation network is to be built. The default value is
#              "pearson"
# corrThresh - floating point number indicating the correlation threshold to
#              consider that two features are correlated. It is only needed if
#              the correlation network is to be built. The default value is
#              0.25 (i.e., at least 25% of correlation between the abundance
#              values, either positive or negative)
# OUTPUT: list of experimental networks as igraph objects
#' @name buildExpNet
#'
#' @aliases buildExpNet
#'
#' @title Build experimental networks
#'
#' @description
#' The function `buildExpNet` builds experimental networks, based on spectral
#' similarity, correlation, and mass difference
#'
#' @param inputData
#' `list`, list returned by the `loadInputData` function
#'
#' @param net2Build
#' `list`, list of experimental networks to build, according to the following
#' options:
#'    "all" - generates 3 experimental networks: mass difference, correlation,
#'    and spectral similarity,
#'    "m" - builds the mass difference network,
#'    "s" - builds the spectral similarity network,
#'    "c" - builds the correlation network.
#'    It is to note that combinations of m, s, and c are possible, writing them
#'    separated by commas, e.g., c("m", "c") would generate the mass
#'    difference, and correlation networks. The default value is "all"
#'
#' @param directed
#' `boolean`, boolean value (TRUE/FALSE). If TRUE then the networks that are
#' generated will be directed, and undirected otherwise. The default value is
#' FALSE (i.e., undirected network)
#'
#' @param ppmMass
#' `numeric`, (optional) allowed error for mass differences calculus. It is
#' only needed if the mass difference network is to be built. The default value
#' is 10
#'
#' @param ppmSpec
#' `numeric`, (optional) relative allowed error for spectral similarity
#' calculus. It is only needed if the spectral similarity network is to be
#' built. The default value is 0
#'
#' @param tol
#' `numeric`, (optional) absolute tolerance for spectral similarity calculus.
#' It is only needed if the spectral similarity network is to be built. The
#' default value is 0.005
#'
#' @param corrModel
#' `vector`, (optional) character vector containing the model(s) to be used for
#' the correlation calculus in MetNet. Please check the available models in the
#' current version of MetNet. There are 10 models available in version 1.14.0:
#' "lasso", "randomForest", "clr", "aracne", "pearson", "pearson_partial",
#' "spearman", "spearman_partial", "ggm", and "bayes". This parameter is only
#' needed if the correlation network is to be built. The default value is
#' "pearson"
#'
#' @param corrThresh
#' `numeric`, (optional) floating point number indicating the correlation
#' threshold to consider that two features are correlated. It is only needed if
#' the correlation network is to be built. The default value is 0.25 (i.e., at
#' least 25% of correlation between the abundance values, either positive or
#' negative)
#'
#' @return
#' List of experimental networks as igraph objects
#'
#' @author Elva Novoa, \email{elva-maria.novoa-del-toro@@inrae.fr}
#'
#' @examples
#' # See the MultiLayerNetwork vignette
#'
#' @export
buildExpNet <- function(inputData, net2Build = "all", directed = FALSE,
  ppmMass = 10, ppmSpec = 0, tol = 0.005, corrModel = "pearson",
  corrThresh = 0.25) {

    # empty list to save the experimental networks
    expNet <- list()

    # check if mass difference network is to be built
    if (any(c("m", "all") %in% net2Build)) {

      # build mass difference network
      res <- buildMassDiffNet(inputData, ppmMass, directed)

      # add network to the list
      expNet[["m"]] <- res$net

      # save the mass difference matrix
      massDiff <- res$massDiff
    }

    # check if spectral similarity network is to be built
    if (any(c("s", "all") %in% net2Build)) {

      # check if the mass difference matrix does not already exists
      if (!exists("massDiff")) {

        # build mass difference network
        res <- buildMassDiffNet(inputData, ppmMass, directed)

        # save the mass difference matrix
        massDiff <- res$massDiff
      }

      # build spectral similarity network
      net <- buildSpecSimNet(inputData, tol, ppmSpec, massDiff, directed)

      # add network to the list
      expNet[["s"]] <- net
    }

    # check if correlation network is to be built
    if (any(c("c", "all") %in% net2Build)) {

      # build correlation network
      net <- buildCorrNet(inputData, directed, corrModel, corrThresh)

      # add network to the list
      expNet[["c"]] <- net
    }

    return(expNet)
  }


# Function to build the mass difference network
# INPUTS:
#  inputData - list returned by the loadInputData function
#  ppmMass   - allowed error for mass differences calculus
#  directed  - boolean value (TRUE/FALSE). If TRUE then the networks that are
#              generated will be directed, and undirected otherwise. The
#              default value is FALSE (i.e., undirected network)
# OUTPUT: mass difference network as igraph object
#' @name buildMassDiffNet
#'
#' @title Build the mass difference network
#'
#' @import igraph
#'
#' @author Elva Novoa, \email{elva-maria.novoa-del-toro@@inrae.fr}
buildMassDiffNet <- function(inputData, ppmMass, directed) {

  # create mass difference adjacency matrix
  massDiff <-
    qfeat_structural(
      x = inputData$peakList,
      assay_name = names(inputData$peakList),
      transformation = inputData$transformations,
      var = c("name", "formula", "mass"),
      ppm = ppmMass
    )

  # add row data
  rowData(massDiff) <-
    as.data.frame(rowData(inputData$peakList[[names(inputData$peakList)]]))

  # get edges from the adjacency matrix
  massDiffDF <- as.data.frame(massDiff) |> filter(binary == 1)

  # create igraph object
  net <-
    igraph::graph_from_data_frame(
      massDiffDF,
      directed = directed,
      vertices = inputData$allComp
      )

  return(list(net = net, massDiff = massDiff))
}


# Function to build the spectral similarity network
# INPUTS:
#  inputData - list returned by the loadInputData function
#  tol       - absolute tolerance for spectral similarity calculus
#  ppmSpec   - relative allowed error for spectral similarity calculus. It is
#              only needed if the spectral similarity network is to be built.
#              The default value is 0
#  massDiff   - mass difference adjacency matrix as generated by MetNet
#  directed  - boolean value (TRUE/FALSE). If TRUE then the networks that are
#              generated will be directed, and undirected otherwise. The
#              default value is FALSE (i.e., undirected network)
# OUTPUT: spectral similarity network as igraph object
#' @name buildSpecSimNet
#'
#' @title Build the spectral similarity network
#'
#' @import igraph MetNet Spectra
#'
#' @author Elva Novoa, \email{elva-maria.novoa-del-toro@@inrae.fr}
buildSpecSimNet <- function(inputData, tol, ppmSpec, massDiff, directed) {

  # calculate spectral similarity
   spectralSim <-
    spec_molNetwork(
      inputData$spectra, MAPFUN = Spectra::joinPeaksGnps, methods = "gnps",
      tolerance = tol, ppm = ppmSpec, type = "inner"
    )

  # add spectral similarity to the structural adjacency matrix from MetNet
  spectralSimA <-
    MetNet::addSpectralSimilarity(
      am_structural = massDiff, ms2_similarity = spectralSim
      )

  # get edges from the adjacency matrix
  spectralSimDF <- as.data.frame(spectralSimA) |> filter(!is.na(gnps)) |>
    filter(binary == 1) |> filter(Row != Col)

  # create igraph object
  net <-
    igraph::graph_from_data_frame(
      spectralSimDF,
      directed = directed,
      vertices = inputData$allComp
      )

  return(net)
}


# Function to build the correlation network
# INPUTS:
#  inputData - list returned by the loadInputData function
#  directed  - boolean value (TRUE/FALSE). If TRUE then the networks that are
#              generated will be directed, and undirected otherwise. The
#              default value is FALSE (i.e., undirected network)
#  corrModel - character vector containing the model(s) to be used for the
#              correlation calculus
# corrThresh - floating point number indicating the correlation threshold to
#              consider that two features are correlated
# OUTPUT: correlation network as igraph object
#' @name buildCorrNet
#'
#' @title Build the correlation network
#'
#' @import igraph
#'
#' @author Elva Novoa, \email{elva-maria.novoa-del-toro@@inrae.fr}
buildCorrNet <- function(inputData, directed, corrModel, corrThresh) {

  # calculate correlation
  corr <-
    qfeat_statistical(
      x = inputData$peakList,
      assay_name = names(inputData$peakList),
      model = corrModel,
      na.omit = TRUE,
      p.adjust = "BH"
    )

  # get edges from the adjacency matrix
  corrDF <- as.data.frame(corr)

  # filter correlation to keep only those above threshold
  corrDF <- corrDF[abs(corrDF[[grep("coef", names(corrDF))]]) >= corrThresh, ]

  # create igraph object
  net <-
    igraph::graph_from_data_frame(
      corrDF,
      directed = directed,
      vertices = inputData$allComp
      )

  return(net)
}


# Function to map the identified experimental nodes to the corresponding
# GSMN nodes, using the CHeBI ontology. This function calls the
# Metabolomics2Networks Python package
# INPUTS:
#   inputData - list returned by the loadInputData function
#   resFile   - file name for the resulting mappings file. The default value
#               is "Res_Met2Net_MappedMet.txt"
# OUTPUT: data frame with the mappings and ontology-based distances
# NOTE. This function also generates a file with the mapping
#' @name mapMetToGSMN
#'
#' @aliases mapMetToGSMN
#'
#' @title Map the experimental nodes to GSMN nodes
#'
#' @description
#' Function to map the identified experimental nodes to the
#' corresponding GSMN nodes, using the CHeBI ontology. This function calls the
#' Metabolomics2Networks Python package
#'
#' @param inputData
#' `list`, list returned by the `loadInputData` function
#'
#' @param resFile
#' `character`, file name for the resulting mappings file. The default value is
#' "Res_Met2Net_MappedMet.txt"
#'
#' @return
#' Data frame with the mappings and ontology-based distances.
#'
#' @author Elva Novoa, \email{elva-maria.novoa-del-toro@@inrae.fr}
#'
#' @examples
#' # See the MultiLayerNetwork vignette
#'
#' @export
mapMetToGSMN <- function(inputData, resFile = "Res_Met2Net_MappedMet.txt") {

  # generate command line to execute metabolites2Network
  com <-
    paste0(
      "python3 ",
      inputData$met2NetDir,
      "metabolomics2network.py tsv ",
      inputData$idenMetF,
      " ",
      inputData$compF,
      " ",
      inputData$resPath,
      resFile,
      " ",
      inputData$configF,
      " 2"
      )

  # execute code
  system(com)

  return()
}


# Function to make the multi-layer network by connecting the Genome-Scale
# Metabolic Network (GSMN) and the experimental networks
# INPUTS:
#  inputData   - list returned by the loadInputData function
#  expNetworks - list returned by the buildExpNet function
#  mappingF    - file in table format containing the mapping between the
#                metabolites from the  experimental networks and those from the
#                GSMN. Such mapping  can be obtained with tools such as
#                Metabolomics2Networks (see the MultiLayerNetwork vignette).
#                The file must contain at least 4 columns, separated by tabs:
#                "metabolite name" (name of the features from the peak list),
#                "mapped on id" (id of the corresponding metabolite from the
#                GSMN), "distance" (distance between the feature and its
#                corresponding metabolite. Note. The distance is equal to zero
#                when the mapping is exact), and "chebi" (ChEBI id of the
#                corresponding metabolite from the GSMN)
# OUTPUT: multi-layer network in list format containing 3 named elements:
#  "layers" (list of igraph objects), "type" (type of layer: Exp/GSMN),
#  "interLayerEdges" (data frame with 3 columns: expNode, gsmnNode, distance)
#' @name makeMultiLayer
#'
#' @aliases makeMultiLayer
#'
#' @title Make a multi-layer network
#'
#' @description
#' Function to make the multi-layer network by connecting the Genome-Scale
#'Metabolic Network (GSMN) and the experimental networks
#'
#' @param inputData
#' `list`, list returned by the `loadInputData` function
#'
#' @param expNetworks
#' `list`, list returned by the buildExpNet function
#'
#' @param mappingF
#' `path`, path to file in table format containing the mapping between the
#' metabolites from the  experimental networks and those from the GSMN. Such
#' mapping  can be obtained with tools such as Metabolomics2Networks (see
#' the MultiLayerNetwork vignette). The file must contain at least 4 columns,
#' separated by tabs: "metabolite name" (name of the features from the peak
#' list), "mapped on id" (id of the corresponding metabolite from the GSMN),
#' "distance" (distance between the feature and its corresponding metabolite.
#' Note. The distance is equal to zero when the mapping is exact), and "chebi"
#' (ChEBI id of the corresponding metabolite from the GSMN)
#'
#' @return
#' Multi-layer network in list format containing 3 named elements:
#  "layers" (list of igraph objects), "type" (type of layer: Exp/GSMN),
#  "interLayerEdges" (data frame with 3 columns: expNode, gsmnNode, distance)
#'
#' @author Elva Novoa, \email{elva-maria.novoa-del-toro@@inrae.fr}
#'
#' @examples
#' # See the MultiLayerNetwork vignette
#'
#' @export
makeMultiLayer <- function(inputData, expNetworks, mappingF) {

  # read table
  mapping <- read.table(mappingF, header = TRUE, sep = "\t")

  # list of columns to keep
  colsToKeep <-  c("metabolite.name", "mapped.on.id", "distance")

  # filter list to keep only mapped nodes
  mappingFiltered <- mapping[mapping$mapped.on.id != "", colsToKeep]

  # create an empty data frame
  interLayerEdges <-
    data.frame(
      expNode = character(), gsmnNode = character(), distance = character()
      )

  # loop to collapse multiple mappings and get all the inter-layer edges
  for (i in seq_len(nrow(mappingFiltered))) {
    feat <- as.character(mappingFiltered[i, 1])
    met <- mappingFiltered[i, 2]
    dis <- mappingFiltered[i, 3]

    # split metabolite names and distances, if needed
    met <- unlist(str_split(str_remove(met, ";$"), ";"))
    dis <- unlist(str_split(str_remove(dis, ";$"), ";"))

    # add current inter-layer edges
    interLayerEdges <-
      rbind(
        interLayerEdges,
        data.frame(expNode = feat, gsmnNode = met, distance = dis)
        )
  }

  # make a multi-layer network with the GSMN and the experimental networks
  multiLayer <-
    list(
      layers = c(expNetworks, gsmn = list(inputData$gsmn)),
      type = c(rep("Exp", length(expNetworks)), "GSMN"),
      interLayerEdges = interLayerEdges
      )

  return(multiLayer)
}



# Function to calculate some statistics of the multi-layer network
# INPUTS:
#  multiLayer  - list returned by the makeMultiLayer function
#  inputData   - list returned by the loadInputData function
# OUTPUT: none, but it creates several plots in the resPath directory
#' @name calculateMultiLayerStats
#'
#' @aliases calculateMultiLayerStats
#'
#' @title Calculate some statistics of the multi-layer network
#'
#' @description
#' Function to calculate some statistics of the multi-layer network
#'
#' @param multiLayer
#' `list`, list containing the multi-layer network as returned by the
#' `makeMultiLayer` function
#'
#' @param inputData
#' `list`, list returned by the `loadInputData` function
#'
#' @return
#' Nothing, but it creates several plots in the resPath directory
#'
#' @author Elva Novoa, \email{elva-maria.novoa-del-toro@@inrae.fr}
#'
#' @examples
#' # See the MultiLayerNetwork vignette
#'
#' @export
calculateMultiLayerStats <- function(multiLayer, inputData) {

  # verify if the results folder does not exist
  if (!file.exists(inputData$resPath)) {

    # create folder
    dir.create(inputData$resPath)
  }

  # make table of frequencies of the mapped GSMN nodes
  t <- makeFeqTable(multiLayer$interLayerEdges$gsmnNode, FALSE, "GSMN_node")

  # make plot
  makeBarPlot(
    resPath = inputData$resPath,
    data = t,
    xAxis = "GSMN_node",
    yAxis = "Freq",
    title = "GSMN nodes mapping frequency",
    vertical = FALSE
    )

  # make table of frequencies of the mapped GSMN nodes distances
  t <- makeFeqTable(multiLayer$interLayerEdges$distance, FALSE, "Distance")

  # make plot
  makeBarPlot(
    resPath = inputData$resPath,
    data = t,
    xAxis = "Distance",
    yAxis = "Freq",
    title = "Ontology distance of the mapped GSMN nodes",
    vertical = TRUE
  )

  return()
}


# Function to make a frequency table
# INPUTS:
#  data       - data to use
#  decreasing - if TRUE the frequencies will be sorted in descending order, or
#               in ascending order, otherwise
#  name       - name to give to the column where the values of the input data
#               will be stored
# OUTPUT: table of frequencies
makeFeqTable <- function(data, decreasing, name) {
  # make table of frequencies
  t <- as.data.frame(sort(table(data), decreasing = decreasing))
  colnames(t)[1] <- name

  return(t)
}


# Function to make and save a bar plot
# INPUTS:
#  resPath  - path to the folder where the results will be stored
#  data     - data frame containing the data to plot
#  xAxis    - column name of the data for the x-axis
#  yAxis    - column name of the data for the y-axis
#  title    - title of the plot
#  vertical - if TRUE, the bars will be vertical, otherwise, they will be
#             horizontal
# OUTPUT: none, but it saves the plot in the resPath directory
#' @name makeBarPlot
#'
#' @title Make and save a bar plot
#'
#' @import ggplot2
#'
#' @author Elva Novoa, \email{elva-maria.novoa-del-toro@@inrae.fr}
makeBarPlot <- function(resPath, data, xAxis, yAxis, title, vertical = TRUE) {

  # make plot
  p <-
    ggplot2::ggplot(
      data = data,
      ggplot2::aes(x = eval(as.symbol(xAxis)), y = eval(as.symbol(yAxis)))
      ) +
    ggplot2::geom_bar(stat = "identity") +
    ggplot2::ggtitle(title) +
    ggplot2::xlab(xAxis) +
    ggplot2::ylab(yAxis) +
    ggplot2::theme(
      plot.title = element_text(hjust = 0.5, face = "bold", size = 16))

  # check orientation
  if (vertical == TRUE) {
    p <-
      p +
      ggplot2::geom_text(
        ggplot2::aes(label = eval(as.symbol(yAxis))), vjust = -0.3, size = 3.5)
  } else {
    p <-
      p +
      ggplot2::geom_text(
        ggplot2::aes(label = eval(as.symbol(yAxis))), hjust = -0.3, size = 3.5
        ) +
      ggplot2::coord_flip()
  }

  # save plot
  ggplot2::ggsave(
    paste0(resPath, str_replace_all(title, " ", "_"), ".png"),
    plot = p,
    dpi = 300
  )

  return()
}


# Function to save the list of edges and nodes from the multi-layer network
# to visualize it in Cytoscape
# INPUTS:
#   inputData  - list containing all the input data
#   multiLayer - list containing the multi-layer network, as returned by the
#                makeMultiLayer function
#   visualize  - if == TRUE, the multi-layer layer will be visualized in
#                Cytoscape (NOTE. Cytoscape needs to be open). The default
#                value is FALSE
# OUTPUT: nothing, but it generates files with the list of nodes, edges, and
#         the Cytoscape visualization (if visualize == TRUE)
#' @name writeMultiLayer
#'
#' @aliases writeMultiLayer
#'
#' @title Save and visualize multi-layer network
#'
#' @description
#' Function to save the list of edges and nodes from the multi-layer network
#' to visualize it in Cytoscape
#'
#' @param inputData
#' `list`, list returned by the `loadInputData` function
#'
#' @param multiLayer
#' `list`, list containing the multi-layer network as returned by the
#' `makeMultiLayer` function
#'
#' @param visualize
#' `boolean`, if == TRUE, the multi-layer layer will be visualized in Cytoscape
#' (NOTE. Cytoscape needs to be open). The default value is FALSE
#'
#' @return
#' Nothing, but it generates files with the list of nodes, edges, and the
#' Cytoscape visualization (if visualize == TRUE)
#'
#' @author Elva Novoa, \email{elva-maria.novoa-del-toro@@inrae.fr}
#'
#' @examples
#' # See the MultiLayerNetwork vignette
#'
#' @export
writeMultiLayer <- function(inputData, multiLayer, visualize = FALSE) {
  # get list of edges
  allEdges <- getEdgeList(multiLayer)

  # save list of edges
  write.csv(
    allEdges,
    paste0(inputData$resPath, "MultiLayer4Cytoscape_EdgeList.csv"),
    row.names = FALSE,
    quote = FALSE
    )

  # get list of nodes
  allNodes <- getNodeList(multiLayer)

  # save list of nodes
  write.csv(
    allNodes,
    paste0(inputData$resPath, "MultiLayer4Cytoscape_NodeList.csv"),
    row.names = FALSE,
    quote = FALSE
    )

  if (visualize == TRUE) {
    # get inter-layer edges
    inter <- allEdges[allEdges[[3]] == "InterLayer", ]

    # get nodes connected by inter-layer edges
    nodes <- allNodes[allNodes[[1]] %in% unique(c(inter[[1]], inter[[2]])), ]

    # get all edges among the nodes that have  inter-layer edges
    edges <-
      allEdges[allEdges[[1]] %in% nodes$node & allEdges[[2]] %in% nodes$node, ]

    # Cytoscape visualization
    cytoscapeVis(
      nodes = nodes, edges = edges, resPath = inputData$resPath,
      mainType = "GSMN", fixedColors = TRUE
      )
  }

  return()
}


# Function to get the list of edges in a multi-layer network
# INPUT: multi-layer network
# OUTPUT: list of edges, including inter-layer ones
#' @name getEdgeList
#'
#' @title Get the list of edges in a multi-layer network
#'
#' @import igraph
#'
#' @author Elva Novoa, \email{elva-maria.novoa-del-toro@@inrae.fr}
getEdgeList <- function(multiLayer) {
  allEdges <-
    data.frame(
      source = character(),
      target = character(),
      interaction = character()
      )

  # get edge list of all the networks and paste it in a single data frame
  for (i in seq_len(length(multiLayer$layers))) {

    # get edge list
    edges <- igraph::as_edgelist(multiLayer$layers[[i]])

    # add to general list
    allEdges <-
      rbind(
        allEdges,
        data.frame(
          source = edges[, 1],
          target = edges[, 2],
          interaction =
            paste(multiLayer$type[i], names(multiLayer$layers)[i], sep = "_")
          )
        )
  }

  # add inter-layer edges
  allEdges <-
    rbind(
      allEdges,
      data.frame(
        source = multiLayer$interLayerEdges[, 1],
        target = multiLayer$interLayerEdges[, 2],
        interaction = "InterLayer"
      )
    )

  return(allEdges)
}


# Function to get the list of nodes in a multi-layer network
# INPUT: multi-layer network
# OUTPUT: list of nodes
#' @name getNodeList
#'
#' @title Get the list of nodes in a multi-layer network
#'
#' @author Elva Novoa, \email{elva-maria.novoa-del-toro@@inrae.fr}
getNodeList <- function(multiLayer) {

  # get types of layers
  type <- unique(multiLayer$type)

  # initialize empty variables
  nodes <- list()
  nodeType <- list()

  # loop through the types of layers
  for (t in type) {
    # get nodes from current type
    n <-
      unique(
        unlist(
          lapply(
            multiLayer$layers[multiLayer$type == t],
            function(X) names(V(X))
            )
          )
        )

    # add nodes to the list
    nodes <- c(nodes, n)

    # add node type
    nodeType <- c(nodeType, rep(t, length(n)))
  }

  # create data frame
  allNodes <-
    data.frame(
      node = unlist(nodes),
      nodeType = unlist(nodeType)
    )

  return(allNodes)
}


# Definition of a function to visualize in Cytoscape the subnetworks of the
# experimental nodes that map to the same metabolite node in the GSMN.
# NOTE. Cytoscape needs to be open
# INPUTS:
#   allNodes    - list of nodes
#   allEdges    - list of edges
#   resPath     - path where the results will be stored
#   mainType    - a subnetwork will be generated for each of the nodes from
#                 this node type so that can observe the connection patterns
#                 between the different edges connecting all the nodes from the
#                 other types that map to each of the nodes from the main type.
#                 The default value is "GSMN"
#   fixedColors - boolean value (TRUE/FALSE), if == TRUE, a set of predefined
#                 colors will be used to style the nodes and edges, as follows:
#                 NODES: {blue = experimental, orange = GSMN},
#                 EDGES: {yellow = correlation, orange = mass difference,
#                         green = spectral similarity, black = GSMN,
#                         blue = inter-layer}.
#                 If fixedColors == FALSE, the colors of the nodes and edges
#                 will be assigned automatically. The default value is TRUE
# OUTPUT: None, but it generates a Cytoscape file with the visualization
#' @name cytoscapeVis
#'
#' @title Visualize in Cytoscape
#'
#' @import igraph RCy3
#'
#' @author Elva Novoa, \email{elva-maria.novoa-del-toro@@inrae.fr}
cytoscapeVis <- function(nodes, edges, resPath, mainType = "GSMN",
  fixedColors = TRUE) {

    # verify that Cytoscape is launched
    RCy3::cytoscapePing()

    # close any open session
    RCy3::closeSession(save.before.closing = FALSE)

    # create aggregated version of the multi-layer network
    aggregated <-
      igraph::graph_from_data_frame(edges, directed = FALSE, vertices = nodes)

    # visualize aggregated network in Cytoscape
    RCy3::createNetworkFromIgraph(
      aggregated,
      title = "MultiLayer",
      collection = "MultiLayerNetwork"
    )
    RCy3::layoutNetwork(layout.name = "force-directed", network = "MultiLayer")

    # get types of nodes and edges in the network
    nodeTypes <- unique(get.vertex.attribute(aggregated, "nodeType"))
    edgeTypes <- unique(get.edge.attribute(aggregated, "interaction"))

    # get colors to use
    colors <- getColorTable(nodeTypes, edgeTypes, fixedColors)

    # color the nodes
    RCy3::setNodeColorMapping(
      table.column = "nodeType", table.column.values = nodeTypes,
      colors =
        sapply(
          nodeTypes,
          function(X) colors$color[colors$type == "Node" & colors$name == X]
        ),
      mapping.type = "d", network = "MultiLayer", style.name = "default"
    )

    # color the edges
    RCy3::setEdgeColorMapping(
      table.column = "interaction", table.column.values = edgeTypes,
      colors =
        sapply(
          edgeTypes,
          function(X) colors$color[colors$type == "Edge" & colors$name == X]
        ),
      mapping.type = "d", network = "MultiLayer", style.name = "default"
    )

    # get inter-layer edges and nodes connected by them
    inter <- edges[edges[[3]] == "InterLayer", ]

    # get nodes connected by inter-layer edges
    nodesIL <-nodes[nodes[[1]] %in% unique(c(inter[[1]], inter[[2]])), ]

    # get nodes from main node type
    nodesILT <- nodes[nodes$nodeType == mainType, ]

    # loop to generate sub-networks
    for (n in nodesILT$node) {
      # get edges connecting current node
      curEd <- edges[edges$target == n | edges$source == n, ]

      # remove edges from main type
      omit <- grep(mainType, curEd$interaction)
      if (length(omit) > 0) {
        curEd <-  curEd[-omit, ]
      }

      # get list of all nodes connected to current node
      nCon <- unique(c(curEd$source, curEd$target))

      # create subnetwork
      subnet <-
        igraph::subgraph(
          aggregated, vids = which(names(V(aggregated)) %in% nCon))

      # visualize subnetwork in Cytoscape
      RCy3::createNetworkFromIgraph(
        subnet,
        title = paste0(n, "_AllLayers"),
        collection = n
      )
      RCy3::layoutNetwork(
        layout.name = "force-directed", network = paste0(n, "_AllLayers")
        )

      # get types of edges connecting the nodes of current subnetwork
      edgeTypes <- as.vector(unique(edge_attr(subnet, "interaction")))

      # remove inter-layer edges
      edgeTypes <- edgeTypes[- which(edgeTypes == "InterLayer")]

      # loop to generate a subnetwork per edge type
      for(eType in edgeTypes) {
        # select edges of current type
        RCy3::selectEdges(
          edges = eType,
          by.col = "interaction",
          preserve.current.selection = FALSE,
          network = paste0(n, "_AllLayers")
        )

        # select all nodes connected by selected edges
        RCy3::selectNodesConnectedBySelectedEdges(
          network = paste0(n, "_AllLayers"))

        # create subnetwork
        RCy3::createSubnetwork(
          nodes = "selected",
          edges = "selected",
          subnetwork.name = paste0(n, "_", eType),
          network = paste0(n, "_AllLayers"),
        )

        # apply layout
        RCy3::layoutNetwork(
          layout.name = "force-directed", network = paste0(n, "_", eType))
      }
    }

    RCy3::saveSession(paste0(resPath, "Subnetworks_", Sys.Date()))

    return()
  }


# Function to get the table of colors for the nodes and edges
# INPUTS:
#   nodeTypes   - types of nodes in the network to color
#   edgeTypes   - types of edges in the network to color
#   fixedColors - whether to return fixed colors or not
# OUTPUT:
#   data frame of three columns: type, name, and color, containing the colors
#   for the nodes and edges
#' @name getColorTable
#'
#' @title Get the table of colors for the nodes and edges
#'
#' @author Elva Novoa, \email{elva-maria.novoa-del-toro@@inrae.fr}
getColorTable <- function(nodeTypes, edgeTypes, fixedColors) {

  # check whether predefined list of colors is to be used
  if (fixedColors == TRUE) {
    colors <-
      data.frame(
        type = c(rep("Edge", 5), rep("Node", 2)),
        name = c("Exp_c", "Exp_m", "Exp_s", "GSMN_gsmn", "InterLayer", "Exp",
                 "GSMN"),
        # code colors:
        #   #F0E442 = yellow edges (Exp_c), #D55E00 = orange edges (Exp_m),
        #   #009E73 = green edges (Exp_s), #000000 = black edges (GSMN_gsmn),
        #   #0072B2 = blue edges (InterLayer), #56B4E9 = blue nodes (Exp),
        #   #E69F00 = orange nodes (GSMN)
        color = c("#F0E442", "#D55E00", "#009E73", "#000000", "#0072B2",
                  "#56B4E9", "#E69F00")
      )
  } else { # set the colors automatically
    # get number of types of edges and nodes
    edgeTypesNo <- length(edgeTypes)
    nodeTypesNo <- length(nodeTypes)

    # pick blind-color friendly colors
    palette <-
      palette.colors(palette = "Okabe-Ito")[1:(edgeTypesNo + nodeTypesNo)]

    # make data frame with the colors for each type of node and edge
    colors <-
      data.frame(
        type = c(rep("Edge", edgeTypesNo), rep("Node", nodeTypesNo)),
        name = c(edgeTypes, nodeTypes),
        color = palette
      )
  }

  return(colors)
}
