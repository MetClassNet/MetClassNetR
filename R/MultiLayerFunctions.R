library(MetClassNetR)
library(MetNet)
library(Spectra)
library(MsCoreUtils)
library(MsBackendMgf)
library(easyGgplot2)
library(QFeatures)
library(igraph)
library(tidyverse)
library(dplyr)
library(ggplot2)
library(stringr)
library(RCy3)

# Function to load the input data, i.e., the files needed to build the networks
# INPUTS:
#  peakListF     - path to the TSV file that contains the peak list (one peak
#                  per row) in a MetaboLights-like format. The first row is the
#                  header (i.e., the list of columns' names). The file should
#                  contain at least 3 columns: "database_identifier" (ChEBI),
#                  "mass_to_charge", and "retention_time". It is to note that
#                  these column names are fixed. The TSV file can also contain
#                  intensity (or abundance) values. In this case, the column
#                  names are free (e.g., can be named after the samples), but
#                  no blank spaces are allowed and the first character must be
#                  a letter. In addition, all the abundances must be placed at
#                  the end of the table, i.e., in the last columns
#  intCol        - number of the first column containing the intensities or of
#                  the subset of columns to take the intensity values from. The
#                  default value is 23, as in all datasets available in
#                  MetaboLights (https://www.ebi.ac.uk/metabolights)
#  transF        - (optional) path to the CSV file containing the
#                  transformation list. It must contain at  least the columns
#                  "name", "formula", and "mass". This file is needed if the
#                  mass difference network is to be built
#  spectraF      - (optional) path to the MSMS data in MGF format, if available
#  gsmnF         - path to the compound graph in GML format, as generated by
#                  Met4J (https://forgemia.inra.fr/metexplore/met4j). The
#                  compound graphs of some organisms are available in the data
#                  folder
#  spectraSS     - (optional) samples the spectra dataset, according to the
#                  given sample size. This would speed up the process and it
#                  is useful when testing your data and/or this package
#  resPath       - path to the folder where the results will be stored
#  met2NetDir    - path to the directory where the Python package
#                  Metabolomics2Network is
#  configF       - path to the file that contains the column names
#                  (i.e., alias) of the idenMetF file and the information
#                  they contain, such as name, chebi, formula, etc. See an
#                  example in
#                  extdata/MTBLS1586/Metabolomics2NetworksData/JsonConf.txt.
#                  NOTE. This information will be used to do the metabolite
#                  mapping to the GSMN (using metabolomics2Network)
#  idenMetF     - path to the TSV file that contains the list of experimental
#                  features that were identified and that have a CHEBI id
#                  associated. The header of this file must match the aliases
#                  from the configuration file (configF)
#  compF         - path to the TSV file containing the list of compounds in the
#                  GSMN of the organism of interest. They must contain at least
#                  two columns: ID and Chebi. An example can be found in
#                  extdata/MTBLS1586/Metabolomics2NetworksData/WormJamMet.tsv
# OUTPUT:      named list containing all the data (peakList, spectra,
#              transformations, and gsmn)
loadInputData <- function (peakListF, intCol = 23, net2Build = "all", transF,
  spectraF, gsmnF, spectraSS = NULL, resPath, met2NetDir, configF, idenMetF,
  compF) {

  # read peak list
  peakList <- readMaf(peakListF, ecol = intCol)
  data <- read_tsv(peakListF) # read peak list file

  # keep only identified metabolites
  identifiedMet <-
    data[!is.na(data$database_identifier), c("id", "database_identifier")]

  # read fragmentation spectra
  spectra <-
    Spectra(spectraF, source = MsBackendMgf(), backend = MsBackendDataFrame())

  # check if sampling is to be done
  if (!is.null(spectraSS)) {

    # check if sample size < current spectra size
    if (spectraSS < length(spectra)) {

      # sample the fragmentation spectra
      keep <- sample(seq_len(length(spectra)), spectraSS)
      spectra <- spectra[keep]
    }
  }

  # read transformations
  transformations <- read_csv(transF, col_names = TRUE)

  # read GSMN
  gsmn <- read_graph(gsmnF, format = "gml")

  ############################################################# TO REMOVE ????
  # remove compartments from the label of the nodes
  labels <-
    unlist(
      lapply(get.vertex.attribute(gsmn, "label"), function(X) {
        n <- nchar(X)
        substr(X, 1, n-2)
      }
      )
    )
  # set the name of the metabolites
  gsmn <- set.vertex.attribute(gsmn, name = "name", value = labels)

  # sanity checks
  if (!checkQFeatures(peakList)) {
    stop(paste0("Bad peak list. Please check your file ", peakListF))
  } else if (!checkSpectra(spectra)) {
    stop(paste0("Bad spectra. Please check your file ", spectra))
  } else {
    # if the sanity checks are OK, return the read data
    return (
      list(
        peakList = peakList,
        allComp = data$id,
        identifiedMet = identifiedMet,
        spectra = spectra,
        transformations = transformations,
        gsmn = gsmn,
        resPath = resPath,
        configF = configF,
        idenMetF = idenMetF,
        compF = compF,
        met2NetDir = met2NetDir
        )
      )
  }
}


# Function to build experimental networks, based on spectral similarity,
# correlation, and mass difference
# INPUTS:
#  inputData - list returned by the loadInputData function
#  net2Build - list of experimental networks to build, according to the
#              following options:
#               "all" - generates 3 experimental networks: mass difference,
#                     correlation, and spectral similarity,
#               "m" - builds the mass difference network,
#               "s" - builds the spectral similarity network,
#               "c" - builds the correlation network.
#              It is to note that combinations of m, s, and c are possible,
#              writing them separated by commas, e.g., c("m", "c") would
#              generate the mass difference and correlation networks. The
#              default value is "all"
#  directed  - boolean value (TRUE/FALSE). If TRUE then the networks that are
#              generated will be directed, and undirected otherwise. The
#              default value is FALSE (i.e., undirected network)
#  ppmMass   - allowed error for mass differences calculus. It is only needed
#              if the mass difference network is to be built. The default value
#              is 10
#  ppmSpec   - relative allowed error for spectral similarity calculus. It is
#              only needed if the spectral similarity network is to be built.
#              The default value is 0
#  tol       - absolute tolerance for spectral similarity calculus. It is only
#              needed if the spectral similarity network is to be built. The
#              default value is 0.005
#  corrModel - character vector containing the model(s) to be used for the
#              correlation calculus. There are 11 models available: "lasso",
#              "randomForest", "clr", "aracne", "pearson", "pearson_partial",
#              "pearson_semipartial", "spearman", "spearman_partial",
#              "spearman_semipartial", and "bayes". This parameter is only
#              needed if the correlation network is to be built. The default
#              value is "pearson"
# corrThresh - floating point number indicating the correlation threshold to
#              consider that two features are correlated. It is only needed if
#              the correlation network is to be built. The default value is
#              0.25 (i.e., at least 25% of correlation between the abundance
#              values, either positive or negative)
# OUTPUT: list of experimental networks as igraph objects
buildExpNet <-
  function(
    inputData, net2Build = "all", directed = FALSE, ppmMass = 10, ppmSpec = 0,
    tol = 0.005, corrModel = "pearson", corrThresh = 0.25) {

    # empty list to save the experimental networks
    expNet <- list()

    # check if mass difference network is to be built
    if (any(c("m", "all") %in% net2Build)) {

      # build mass difference network
      res <- buildMassDiffNet(inputData, ppmMass, directed)

      # add network to the list
      expNet[["m"]] <- res$net

      # save the mass difference matrix
      massDiff <- res$massDiff
    }

    # check if spectral similarity network is to be built
    if (any(c("s", "all") %in% net2Build)) {

      # check if the mass difference matrix does not already exists
      if (!exists("massDiff")) {

        # build mass difference network
        res <- buildMassDiffNet(inputData, ppmMass, directed)

        # save the mass difference matrix
        massDiff <- res$massDiff
      }

      # build spectral similarity network
      net <- buildSpecSimNet(inputData, tol, ppmSpec, massDiff, directed)

      # add network to the list
      expNet[["s"]] <- net
    }

    # check if correlation network is to be built
    if (any(c("c", "all") %in% net2Build)) {

      # build correlation network
      net <- buildCorrNet(inputData, directed, corrModel, corrThresh)

      # add network to the list
      expNet[["c"]] <- net
    }

    return(expNet)
  }


# Function to build the mass difference network
# INPUTS:
#  inputData - list returned by the loadInputData function
#  ppmMass   - allowed error for mass differences calculus
#  directed  - boolean value (TRUE/FALSE). If TRUE then the networks that are
#              generated will be directed, and undirected otherwise. The
#              default value is FALSE (i.e., undirected network)
# OUTPUT: mass difference network as igraph object
buildMassDiffNet <- function(inputData, ppmMass, directed) {

  # create mass difference adjacency matrix
  massDiff <-
    qfeat_structural(
      x = inputData$peakList,
      assay_name = names(inputData$peakList),
      transformation = inputData$transformations,
      var = c("name", "formula", "mass"),
      ppm = ppmMass
    )

  # add row data
  rowData(massDiff) <-
    as.data.frame(rowData(inputData$peakList[[names(inputData$peakList)]]))

  # get edges from the adjacency matrix
  massDiffDF <- as.data.frame(massDiff) |> filter(binary == 1)

  # create igraph object
  net <-
    graph_from_data_frame(
      massDiffDF,
      directed = directed,
      vertices = inputData$allComp
      )

  return(list(net = net, massDiff = massDiff))
}


# Function to build the spectral similarity network
# INPUTS:
#  inputData - list returned by the loadInputData function
#  tol       - absolute tolerance for spectral similarity calculus
#  ppmSpec   - relative allowed error for spectral similarity calculus. It is
#              only needed if the spectral similarity network is to be built.
#              The default value is 0
#  massDiff   - mass difference adjacency matrix as generated by MetNet
#  directed  - boolean value (TRUE/FALSE). If TRUE then the networks that are
#              generated will be directed, and undirected otherwise. The
#              default value is FALSE (i.e., undirected network)
# OUTPUT: spectral similarity network as igraph object
buildSpecSimNet <- function(inputData, tol, ppmSpec, massDiff, directed) {

  # calculate spectral similarity
   spectralSim <-
    spec_molNetwork(
      inputData$spectra, MAPFUN = joinPeaksGnps, methods = "gnps",
      tolerance = tol, ppm = ppmSpec, type = "inner"
    )

  # add spectral similarity to the structural adjacency matrix from MetNet
  spectralSimA <-
    addSpectralSimilarity(
      am_structural = massDiff, ms2_similarity = spectralSim
      )

  # get edges from the adjacency matrix
  spectralSimDF <- as.data.frame(spectralSimA) |> filter(!is.na(gnps)) |>
    filter(binary == 1) |> filter(Row != Col)

  # create igraph object
  net <-
    graph_from_data_frame(
      spectralSimDF,
      directed = directed,
      vertices = inputData$allComp
      )

  return(net)
}


# Function to build the correlation network
# INPUTS:
#  inputData - list returned by the loadInputData function
#  directed  - boolean value (TRUE/FALSE). If TRUE then the networks that are
#              generated will be directed, and undirected otherwise. The
#              default value is FALSE (i.e., undirected network)
#  corrModel - character vector containing the model(s) to be used for the
#              correlation calculus
# corrThresh - floating point number indicating the correlation threshold to
#              consider that two features are correlated
# OUTPUT: correlation network as igraph object
buildCorrNet <- function(inputData, directed, corrModel, corrThresh) {

  # calculate correlation
  corr <-
    qfeat_statistical(
      x = inputData$peakList,
      assay_name = names(inputData$peakList),
      model = corrModel,
      na.omit = TRUE,
      p.adjust = "BH"
    )

  # get edges from the adjacency matrix
  corrDF <- as.data.frame(corr)

  # filter correlation to keep only those above threshold
  corrDF <- corrDF[abs(corrDF[[grep("coef", names(corrDF))]]) >= corrThresh, ]

  # create igraph object
  net <-
    graph_from_data_frame(
      corrDF,
      directed = directed,
      vertices = inputData$allComp
      )

  # # save correlation coefficients
  # corrCoeff <-
  #   data.frame(
  #     coef = c(corrDF$pearson_partial_coef, corrDF$ggm_coef),
  #     group = c(rep("pearsPart", nrow(corrDF)), rep("GGM", nrow(corrDF)))
  #   )
  #
  # # plot to view the distribution of correlations
  # plot <-
  #   ggplot2.histogram(
  #     data = corrCoeff, xName = 'coef', groupName = 'group',
  #     legendPosition = "right", alpha = 0.5, binwidth = 0.01,
  #     brewerPalette = "Paired", addMeanLine = TRUE, meanLineSize = 1
  #   )
  #
  # plot <-
  #   ggplot2.customize(
  #     plot, xtitle = "Correlation coefficient", ytitle = "Count",
  #     showLegend = TRUE, axisLine = c(0.5, "solid", "black"),
  #     addDensity = TRUE, removePanelBorder = TRUE,
  #     backgroundColor = "white", mainTitle = "Correlation coefficient"
  #   )
  #
  # plot

  return(net)
}


# Function to map the identified experimental nodes to the corresponding
# GSMN nodes, using the CHeBI ontology. This function calls the
# Metabolomics2Networks Python package
# INPUTS:
#   inputData - list returned by the loadInputData function
#   resFile   - file name for the resulting mappings file. The default value
#               is "Res_Met2Net_MappedMetabolites.txt"
# OUTPUT: data frame with the mappings and ontology-based distances.
# NOTE. This function also generates a file with the mapping
mapMetabolitesToGSMN <-
  function(inputData, resFile = "Res_Met2Net_MappedMetabolites.txt") {

  # generate command line to execute metabolites2Network
  com <-
    paste0(
      "python3 ",
      inputData$met2NetDir,
      "metabolomics2network.py tsv ",
      inputData$idenMetF,
      " ",
      inputData$compF,
      " ",
      inputData$resPath,
      resFile,
      " ",
      inputData$configF,
      " 2"
      )

  # execute code
  system(com)

  return()
}


# Function to make the multi-layer network by connecting the Genome-Scale
# Metabolic Network (GSMN) and the experimental networks
# INPUTS:
#  inputData   - list returned by the loadInputData function
#  expNetworks - list returned by the buildExpNet function
#  mappingF    - file in table format containing the mapping between the
#                metabolites from the  experimental networks and those from the
#                GSMN. Such mapping  can be obtained with tools such as
#                Metabolomics2Networks (see the MultiLayerNetwork vignette).
#                The file must contain at least 4 columns, separated by tabs:
#                "metabolite name" (name of the features from the peak list),
#                "mapped on id" (id of the corresponding metabolite from the
#                GSMN), "distance" (distance between the feature and its
#                corresponding metabolite. Note. The distance is equal to zero
#                when the mapping is exact), and "chebi" (ChEBI id of the
#                corresponding metabolite from the GSMN)
# OUTPUT: multi-layer network in list format containing 3 named elements:
#  "layers" (list of igraph objects), "type" (type of layer: Exp/GSMN),
#  "interLayerEdges" (data frame with 3 columns: expNode, gsmnNode, distance)
makeMultiLayer <- function(inputData, expNetworks, mappingF) {

  # read table
  mapping <- read.table(mappingF, header = TRUE, sep = "\t")

  # list of columns to keep
  colsToKeep <-  c("metabolite.name", "mapped.on.id", "distance")

  # filter list to keep only mapped nodes
  mappingFiltered <- mapping[mapping$mapped.on.id != "", colsToKeep]

  # create an empty data frame
  interLayerEdges <-
    data.frame(
      expNode = character(), gsmnNode = character(), distance = character()
      )

  # loop to collapse multiple mappings and get all the inter-layer edges
  for (i in seq_len(nrow(mappingFiltered))) {
    feat <- as.character(mappingFiltered[i, 1])
    met <- mappingFiltered[i, 2]
    dis <- mappingFiltered[i, 3]

    # split metabolite names and distances, if needed
    met <- unlist(str_split(str_remove(met, ";$"), ";"))
    dis <- unlist(str_split(str_remove(dis, ";$"), ";"))

    # add current inter-layer edges
    interLayerEdges <-
      rbind(
        interLayerEdges,
        data.frame(expNode = feat, gsmnNode = met, distance = dis)
        )
  }

  # make a multi-layer network with the GSMN and the experimental networks
  multiLayer <-
    list(
      layers = c(expNetworks, gsmn = list(inputData$gsmn)),
      type = c(rep("Exp", length(expNetworks)), "GSMN"),
      interLayerEdges = interLayerEdges
      )

  return(multiLayer)
}



# Function to calculate some statistics of the multi-layer network
# INPUTS:
#  multiLayer  - list returned by the makeMultiLayer function
# OUTPUT: none, but it creates several plots in the resPath directory
calculateMultiLayerStats <- function(multiLayer) {

  # verify if the results folder does not exist
  if (!file.exists(inputData$resPath)) {

    # create folder
    dir.create(inputData$resPath)
  }

  # make table of frequencies of the mapped GSMN nodes
  t <- makeFeqTable(multiLayer$interLayerEdges$gsmnNode, FALSE, "GSMN_node")

  # make plot
  makeBarPlot(
    resPath = inputData$resPath,
    data = t,
    xAxis = "GSMN_node",
    yAxis = "Freq",
    title = "GSMN nodes mapping frequency",
    vertical = FALSE
    )

  # make table of frequencies of the mapped GSMN nodes distances
  t <- makeFeqTable(multiLayer$interLayerEdges$distance, FALSE, "Distance")

  # make plot
  makeBarPlot(
    resPath = inputData$resPath,
    data = t,
    xAxis = "Distance",
    yAxis = "Freq",
    title = "Ontology distance of the mapped GSMN nodes",
    vertical = TRUE
  )

  return()
}


# Function to make a frequency table
# INPUTS:
#  data       - data to use
#  decreasing - if TRUE the frequencies will be sorted in descending order, or
#               in ascending order, otherwise
#  name       - name to give to the column where the values of the input data
#               will be stored
# OUTPUT: table of frequencies
makeFeqTable <- function(data, decreasing, name) {
  # make table of frequencies
  t <- as.data.frame(sort(table(data), decreasing = decreasing))
  colnames(t)[1] <- name

  return(t)
}



# Function to make and save a bar plot
# INPUTS:
#  resPath  - path to the folder where the results will be stored
#  data     - data frame containing the data to plot
#  xAxis    - column name of the data for the x-axis
#  yAxis    - column name of the data for the y-axis
#  title    - title of the plot
#  vertical - if TRUE, the bars will be vertical, otherwise, they will be
#             horizontal
# OUTPUT: none, but it saves the plot in the resPath directory
makeBarPlot <- function(resPath, data, xAxis, yAxis, title, vertical = TRUE) {
  # make plot
  p <-
    ggplot(
      data = data,
      aes(x = eval(as.symbol(xAxis)),
          y = eval(as.symbol(yAxis))
         )
      ) +
    geom_bar(stat = "identity") +
    ggtitle(title) +
    xlab(xAxis) +
    ylab(yAxis) +
    theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 16))

  # check orientation
  if (vertical == TRUE) {
    p <-
      p +
      geom_text(aes(label = eval(as.symbol(yAxis))), vjust = -0.3, size = 3.5)
  } else {
    p <-
      p +
      geom_text(
        aes(label = eval(as.symbol(yAxis))), hjust = -0.3, size = 3.5
        ) +
      coord_flip()
  }

  # save plot
  ggsave(
    paste0(resPath, str_replace_all(title, " ", "_"), ".png"),
    plot = p,
    dpi = 300
  )

  return()
}



# Function to save the list of edges and nodes from the multi-layer network
# to visualize it in Cytoscape
# INPUTS:
#   inputData  - list containing all the input data
#   multiLayer - list containing the multi-layer network
#   visualize  - if == TRUE, the multi-layer layer will be visualized in
#                Cytoscape (NOTE. Cytoscape needs to be open). The default
#                value is FALSE
# OUTPUT: nothing, but it generates files with the list of nodes, edges, and
#         the Cytoscape visualization (if visualize == TRUE)
saveMultiLayer <- function(inputData, multiLayer, visualize = FALSE) {
  # get list of edges
  allEdges <- getEdgeList(multiLayer)

  # save list of edges
  write.csv(
    allEdges,
    paste0(inputData$resPath, "MultiLayer4Cytoscape_EdgeList.csv"),
    row.names = FALSE,
    quote = FALSE
    )

  # get list of nodes
  allNodes <- getNodeList(multiLayer)

  # save list of nodes
  write.csv(
    allNodes,
    paste0(inputData$resPath, "MultiLayer4Cytoscape_NodeList.csv"),
    row.names = FALSE,
    quote = FALSE
    )

  if (visualize == TRUE) {
    # get inter-layer edges
    inter <- allEdges[allEdges[[3]] == "InterLayer", ]

    # get nodes connected by inter-layer edges
    nodes <- allNodes[allNodes[[1]] %in% unique(c(inter[[1]], inter[[2]])), ]

    # get all edges among the nodes that have  inter-layer edges
    edges <-
      allEdges[allEdges[[1]] %in% nodes$node & allEdges[[2]] %in% nodes$node, ]

    # Cytoscape visualization
    cytoscapeVis(
      nodes = nodes, edges = edges, resPath = inputData$resPath,
      mainType = "GSMN", fixedColors = TRUE
      )
  }

  return()
}


# Function to get the list of edges in a multi-layer network
# INPUT: multi-layer network
# OUTPUT: list of edges, including inter-layer ones
getEdgeList <- function(multiLayer) {
  allEdges <-
    data.frame(
      source = character(),
      target = character(),
      interaction = character()
      )

  # get edge list of all the networks and paste it in a single data frame
  for (i in seq_len(length(multiLayer$layers))) {

    # get edge list
    edges <- as_edgelist(multiLayer$layers[[i]])

    # add to general list
    allEdges <-
      rbind(
        allEdges,
        data.frame(
          source = edges[, 1],
          target = edges[, 2],
          interaction =
            paste(multiLayer$type[i], names(multiLayer$layers)[i], sep = "_")
          )
        )
  }

  # add inter-layer edges
  allEdges <-
    rbind(
      allEdges,
      data.frame(
        source = multiLayer$interLayerEdges[, 1],
        target = multiLayer$interLayerEdges[, 2],
        interaction = "InterLayer"
      )
    )

  return(allEdges)
}


# Function to get the list of nodes in a multi-layer network
# INPUT: multi-layer network
# OUTPUT: list of nodes
getNodeList <- function(multiLayer) {
  # get types of layers
  type <- unique(multiLayer$type)

  # initialize empty variables
  nodes <- list()
  nodeType <- list()

  # loop through the types of layers
  for (t in type) {
    # get nodes from current type
    n <-
      unique(
        unlist(
          lapply(
            multiLayer$layers[multiLayer$type == t],
            function(X) names(V(X))
            )
          )
        )

    # add nodes to the list
    nodes <- c(nodes, n)

    # add node type
    nodeType <- c(nodeType, rep(t, length(n)))
  }

  # create data frame
  allNodes <-
    data.frame(
      node = unlist(nodes),
      nodeType = unlist(nodeType)
    )

  return(allNodes)
}


# Definition of a function to visualize in Cytoscape the subnetworks of the
# experimental nodes that map to the same metabolite node in the GSMN.
# NOTE. Cytoscape needs to be open
# INPUTS:
#   allNodes    - list of nodes
#   allEdges    - list of edges
#   resPath     - path where the results will be stored
#   mainType    - a subnetwork will be generated for each of the nodes from
#                 this node type so that can observe the connection patterns
#                 between the different edges connecting all the nodes from the
#                 other types that map to each of the nodes from the main type.
#                 The default value is "GSMN"
#   fixedColors - boolean value (TRUE/FALSE), if == TRUE, a set of predefined
#                 colors will be used to style the nodes and edges, as follows:
#                 NODES: {blue = experimental, orange = GSMN},
#                 EDGES: {yellow = correlation, orange = mass difference,
#                         green = spectral similarity, black = GSMN,
#                         blue = inter-layer}.
#                 If fixedColors == FALSE, the colors of the nodes and edges
#                 will be assigned automatically. The default value is TRUE
# OUTPUT: None, but it generates a Cytoscape file with the visualization
cytoscapeVis <-
  function(nodes, edges, resPath, mainType = "GSMN", fixedColors = TRUE) {
    # verify that Cytoscape is launched
    cytoscapePing()

    # close any open session
    closeSession(save.before.closing = FALSE)

    # create aggregated version of the multi-layer network
    aggregated <-
      graph_from_data_frame(edges, directed = FALSE, vertices = nodes)

    # visualize aggregated network in Cytoscape
    createNetworkFromIgraph(
      aggregated,
      title = "MultiLayer",
      collection = "MultiLayerNetwork"
    )
    layoutNetwork(layout.name = "force-directed", network = "MultiLayer")

    # get types of nodes and edges in the network
    nodeTypes <- unique(get.vertex.attribute(aggregated, "nodeType"))
    edgeTypes <- unique(get.edge.attribute(aggregated, "interaction"))

    # get colors to use
    colors <- getColorTable(nodeTypes, edgeTypes, fixedColors)

    # color the nodes
    setNodeColorMapping(
      table.column = "nodeType", table.column.values = nodeTypes,
      colors =
        sapply(
          nodeTypes,
          function(X) colors$color[colors$type == "Node" & colors$name == X]
        ),
      mapping.type = "d", network = "MultiLayer", style.name = "default"
    )

    # color the edges
    setEdgeColorMapping(
      table.column = "interaction", table.column.values = edgeTypes,
      colors =
        sapply(
          edgeTypes,
          function(X) colors$color[colors$type == "Edge" & colors$name == X]
        ),
      mapping.type = "d", network = "MultiLayer", style.name = "default"
    )

    # get inter-layer edges and nodes connected by them
    inter <- edges[edges[[3]] == "InterLayer", ]

    # get nodes connected by inter-layer edges
    nodesIL <-nodes[nodes[[1]] %in% unique(c(inter[[1]], inter[[2]])), ]

    # get nodes from main node type
    nodesILT <- nodes[nodes$nodeType == mainType, ]

    # loop to generate sub-networks
    for (n in nodesILT$node) {
      # get edges connecting current node
      curEd <- edges[edges$target == n | edges$source == n, ]

      # remove edges from main type
      omit <- grep(mainType, curEd$interaction)
      if (length(omit) > 0) {
        curEd <-  curEd[-omit, ]
      }

      # get list of all nodes connected to current node
      nCon <- unique(c(curEd$source, curEd$target))

      # create subnetwork
      subnet <-
        subgraph(aggregated, vids = which(names(V(aggregated)) %in% nCon))

      # visualize subnetwork in Cytoscape
      createNetworkFromIgraph(
        subnet,
        title = paste0(n, "_AllLayers"),
        collection = n
      )
      layoutNetwork(
        layout.name = "force-directed", network = paste0(n, "_AllLayers")
        )

      # get types of edges connecting the nodes of current subnetwork
      edgeTypes <- as.vector(unique(edge_attr(subnet, "interaction")))

      # remove inter-layer edges
      edgeTypes <- edgeTypes[- which(edgeTypes == "InterLayer")]

      # loop to generate a subnetwork per edge type
      for(eType in edgeTypes) {
        # select edges of current type
        selectEdges(
          edges = eType,
          by.col = "interaction",
          preserve.current.selection = FALSE,
          network = paste0(n, "_AllLayers")
        )

        # select all nodes connected by selected edges
        selectNodesConnectedBySelectedEdges(network = paste0(n, "_AllLayers"))

        # create subnetwork
        createSubnetwork(
          nodes = "selected",
          edges = "selected",
          subnetwork.name = paste0(n, "_", eType),
          network = paste0(n, "_AllLayers"),
        )

        # apply layout
        layoutNetwork(
          layout.name = "force-directed", network = paste0(n, "_", eType))
      }
    }

    saveSession(paste0(resPath, "Subnetworks_", Sys.Date()))

    return()
  }


# Function to get the table of colors for the nodes and edges
# INPUTS:
#   nodeTypes   - types of nodes in the network to color
#   edgeTypes   - types of edges in the network to color
#   fixedColors - whether to return fixed colors or not
# OUTPUT:
#   data frame of three columns: type, name, and color, containing the colors
#   for the nodes and edges
getColorTable <- function(nodeTypes, edgeTypes, fixedColors) {
  # check whether predefined list of colors is to be used
  if (fixedColors == TRUE) {
    colors <-
      data.frame(
        type = c(rep("Edge", 5), rep("Node", 2)),
        name = c("Exp_c", "Exp_m", "Exp_s", "GSMN_gsmn", "InterLayer", "Exp",
                 "GSMN"),
        # code colors:
        #   #F0E442 = yellow edges (Exp_c), #D55E00 = orange edges (Exp_m),
        #   #009E73 = green edges (Exp_s), #000000 = black edges (GSMN_gsmn),
        #   #0072B2 = blue edges (InterLayer), #56B4E9 = blue nodes (Exp),
        #   #E69F00 = orange nodes (GSMN)
        color = c("#F0E442", "#D55E00", "#009E73", "#000000", "#0072B2",
                  "#56B4E9", "#E69F00")
      )
  } else { # set the colors automatically
    # get number of types of edges and nodes
    edgeTypesNo <- length(edgeTypes)
    nodeTypesNo <- length(nodeTypes)

    # pick blind-color friendly colors
    palette <-
      palette.colors(palette = "Okabe-Ito")[1:(edgeTypesNo + nodeTypesNo)]

    # make data frame with the colors for each type of node and edge
    colors <-
      data.frame(
        type = c(rep("Edge", edgeTypesNo), rep("Node", nodeTypesNo)),
        name = c(edgeTypes, nodeTypes),
        color = palette
      )
  }

  return(colors)
}
