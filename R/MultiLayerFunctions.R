library(MetClassNetR)
library(MetNet)
library(Spectra)
library(MsCoreUtils)
library(MsBackendMgf)
library(easyGgplot2)
library(QFeatures)
library(igraph)
library(tidyverse)
library(reticulate)
library(dplyr)
library(muxViz)
library(ggplot2)
library(stringr)
library(reticulate)
library(RCy3)

# Function to load the input data, i.e., the files needed to build the networks
# INPUTS:
#  peakListF - path to the TSV file that contains the peak list (one peak per
#              row) in a MetaboLights-like format. The first row is the header
#              (i.e., the list of columns' names). The file should contain at
#              least 3 columns: "database_identifier" (ChEBI),
#              "mass_to_charge", and "retention_time". It is to note that these
#              column names are fixed. The TSV file can also contain intensity
#              (or abundance) values. In this case, the column names are free
#              (e.g., can be named after the samples), but no blank spaces are
#              allowed and the first character must be a letter. In addition,
#              all the abundances must be placed at the end of the table, i.e.,
#              in the last columns
#  intCol -    number of the first column containing the intensities or of the
#              subset of columns to take the intensity values from. The default
#              value is 23, as in all datasets available in MetaboLights
#              (https://www.ebi.ac.uk/metabolights)
#  transF -    (optional) path to the CSV file containing the transformation
#              list. It must contain at  least the columns "name", "formula",
#              and "mass". This file is needed if the mass difference network
#              is to be built
#  spectraF -  (optional) path to the MSMS data in MGF format, if available
#  gsmnF -     path to the compound graph in GML format, as generated by Met4J
#              (https://forgemia.inra.fr/metexplore/met4j). The compound graphs
#              of some organisms are available in the data folder
#  spectraSS - (optional) samples the spectra dataset, according to the given
#              sample size. This would speed up the process and it is useful
#              when testing your data and/or this package
#  resPath   - path to the folder where the results will be stored
# OUTPUT:      named list containing all the data (peakList, spectra,
#              transformations, and gsmn)
loadInputData <- function (peakListF, intCol = 23, net2Build = "all", transF,
  spectraF, gsmnF, spectraSS = NULL, resPath) {

  # read peak list
  peakList <- readMaf(peakListF, ecol = intCol)
  data <- read_tsv(peakListF) # read peak list file

  # keep only identified metabolites
  identifiedMet <-
    data[!is.na(data$database_identifier), c("id", "database_identifier")]

  # read fragmentation spectra
  spectra <-
    Spectra(spectraF, source = MsBackendMgf(), backend = MsBackendDataFrame())

  # check if sampling is to be done
  if (!is.null(spectraSS)) {

    # check if sample size < current spectra size
    if (spectraSS < length(spectra)) {

      # sample the fragmentation spectra
      keep <- sample(seq_len(length(spectra)), spectraSS)
      spectra <- spectra[keep]
    }
  }

  # read transformations
  transformations <- read_csv(transF, col_names = TRUE)

  # read GSMN
  gsmn <- read_graph(gsmnF, format = "gml")

  ############################################################# TO REMOVE ????
  # remove compartments from the label of the nodes
  labels <-
    unlist(
      lapply(get.vertex.attribute(gsmn, "label"), function(X) {
        n <- nchar(X)
        substr(X, 1, n-2)
      }
      )
    )
  # set the name of the metabolites
  gsmn <- set.vertex.attribute(gsmn, name = "name", value = labels)

  # sanity checks
  if (!checkQFeatures(peakList)) {
    stop(paste0("Bad peak list. Please check your file ", peakListF))
  } else if (!checkSpectra(spectra)) {
    stop(paste0("Bad spectra. Please check your file ", spectra))
  } else {
    # if the sanity checks are OK, return the read data
    return (
      list(
        peakList = peakList,
        allComp = data$id,
        identifiedMet = identifiedMet,
        spectra = spectra,
        transformations = transformations,
        gsmn = gsmn,
        resPath = resPath
        )
      )
  }
}

# Function to build experimental networks, based on spectral similarity,
# correlation, and mass difference
# INPUTS:
#  inputData - list returned by the loadInputData function
#  net2Build - list of experimental networks to build, according to the
#              following options:
#               "all" - generates 3 experimental networks: mass difference,
#                     correlation, and spectral similarity,
#               "m" - builds the mass difference network,
#               "s" - builds the spectral similarity network,
#               "c" - builds the correlation network.
#              It is to note that combinations of m, s, and c are possible,
#              writing them separated by commas, e.g., c("m", "c") would
#              generate the mass difference and correlation networks. The
#              default value is "all"
#  directed  - boolean value (TRUE/FALSE). If TRUE then the networks that are
#              generated will be directed, and undirected otherwise. The
#              default value is FALSE (i.e., undirected network)
#  ppmMass   - allowed error for mass differences calculus. It is only needed
#              if the mass difference network is to be built. The default value
#              is 10
#  ppmSpec   - relative allowed error for spectral similarity calculus. It is
#              only needed if the spectral similarity network is to be built.
#              The default value is 0
#  tol       - absolute tolerance for spectral similarity calculus. It is only
#              needed if the spectral similarity network is to be built. The
#              default value is 0.005
#  corrModel - character vector containing the model(s) to be used for the
#              correlation calculus. There are 11 models available: "lasso",
#              "randomForest", "clr", "aracne", "pearson", "pearson_partial",
#              "pearson_semipartial", "spearman", "spearman_partial",
#              "spearman_semipartial", and "bayes". This parameter is only
#              needed if the correlation network is to be built. The default
#              value is "pearson"
# corrThresh - floating point number indicating the correlation threshold to
#              consider that two features are correlated. It is only needed if
#              the correlation network is to be built. The default value is
#              0.25 (i.e., at least 25% of correlation between the abundance
#              values, either positive or negative)
# OUTPUT: list of experimental networks as igraph objects
buildExpNet <-
  function(
    inputData, net2Build = "all", directed = FALSE, ppmMass = 10, ppmSpec = 0,
    tol = 0.005, corrModel = "pearson", corrThresh = 0.25) {

    # empty list to save the experimental networks
    expNet <- list()

    # check if mass difference network is to be built
    if (any(c("m", "all") %in% net2Build)) {

      # build mass difference network
      res <- buildMassDiffNet(inputData, ppmMass, directed)

      # add network to the list
      expNet[["m"]] <- res$net

      # save the mass difference matrix
      massDiff <- res$massDiff
    }

    # check if spectral similarity network is to be built
    if (any(c("s", "all") %in% net2Build)) {

      # check if the mass difference matrix does not already exists
      if (!exists("massDiff")) {

        # build mass difference network
        res <- buildMassDiffNet(inputData, ppmMass, directed)

        # save the mass difference matrix
        massDiff <- res$massDiff
      }

      # build spectral similarity network
      net <- buildSpecSimNet(inputData, tol, ppmSpec, massDiff, directed)

      # add network to the list
      expNet[["s"]] <- net
    }

    # check if correlation network is to be built
    if (any(c("c", "all") %in% net2Build)) {

      # build correlation network
      net <- buildCorrNet(inputData, directed, corrModel, corrThresh)

      # add network to the list
      expNet[["c"]] <- net
    }

    return(expNet)
  }


# Function to build the mass difference network
# INPUTS:
#  inputData - list returned by the loadInputData function
#  ppmMass   - allowed error for mass differences calculus
#  directed  - boolean value (TRUE/FALSE). If TRUE then the networks that are
#              generated will be directed, and undirected otherwise. The
#              default value is FALSE (i.e., undirected network)
# OUTPUT: mass difference network as igraph object
buildMassDiffNet <- function(inputData, ppmMass, directed) {

  # create mass difference adjacency matrix
  massDiff <-
    qfeat_structural(
      x = inputData$peakList,
      assay_name = names(inputData$peakList),
      transformation = inputData$transformations,
      var = c("name", "formula", "mass"),
      ppm = ppmMass
    )

  # add row data
  rowData(massDiff) <-
    as.data.frame(rowData(inputData$peakList[[names(inputData$peakList)]]))

  # get edges from the adjacency matrix
  massDiffDF <- as.data.frame(massDiff) |> filter(binary == 1)

  # create igraph object
  net <-
    graph_from_data_frame(
      massDiffDF,
      directed = directed,
      vertices = inputData$allComp
      )

  return(list(net = net, massDiff = massDiff))
}


# Function to build the spectral similarity network
# INPUTS:
#  inputData - list returned by the loadInputData function
#  tol       - absolute tolerance for spectral similarity calculus
#  ppmSpec   - relative allowed error for spectral similarity calculus. It is
#              only needed if the spectral similarity network is to be built.
#              The default value is 0
#  massDiff   - mass difference adjacency matrix as generated by MetNet
#  directed  - boolean value (TRUE/FALSE). If TRUE then the networks that are
#              generated will be directed, and undirected otherwise. The
#              default value is FALSE (i.e., undirected network)
# OUTPUT: spectral similarity network as igraph object
buildSpecSimNet <- function(inputData, tol, ppmSpec, massDiff, directed) {

  # calculate spectral similarity
   spectralSim <-
    spec_molNetwork(
      inputData$spectra, MAPFUN = joinPeaksGnps, methods = "gnps",
      tolerance = tol, ppm = ppmSpec, type = "inner"
    )

  # add spectral similarity to the structural adjacency matrix from MetNet
  spectralSimA <-
    addSpectralSimilarity(
      am_structural = massDiff, ms2_similarity = spectralSim
      )

  # get edges from the adjacency matrix
  spectralSimDF <- as.data.frame(spectralSimA) |> filter(!is.na(gnps)) |>
    filter(binary == 1) |> filter(Row != Col)

  # create igraph object
  net <-
    graph_from_data_frame(
      spectralSimDF,
      directed = directed,
      vertices = inputData$allComp
      )

  return(net)
}


# Function to build the correlation network
# INPUTS:
#  inputData - list returned by the loadInputData function
#  directed  - boolean value (TRUE/FALSE). If TRUE then the networks that are
#              generated will be directed, and undirected otherwise. The
#              default value is FALSE (i.e., undirected network)
#  corrModel - character vector containing the model(s) to be used for the
#              correlation calculus
# corrThresh - floating point number indicating the correlation threshold to
#              consider that two features are correlated
# OUTPUT: correlation network as igraph object
buildCorrNet <- function(inputData, directed, corrModel, corrThresh) {

  # calculate correlation
  corr <-
    qfeat_statistical(
      x = inputData$peakList,
      assay_name = names(inputData$peakList),
      model = corrModel,
      na.omit = TRUE,
      p.adjust = "BH"
    )

  # get edges from the adjacency matrix
  corrDF <- as.data.frame(corr)

  # filter correlation to keep only those above threshold
  corrDF <- corrDF[abs(corrDF[[grep("coef", names(corrDF))]]) >= corrThresh, ]

  # create igraph object
  net <-
    graph_from_data_frame(
      corrDF,
      directed = directed,
      vertices = inputData$allComp
      )

  # # save correlation coefficients
  # corrCoeff <-
  #   data.frame(
  #     coef = c(corrDF$pearson_partial_coef, corrDF$ggm_coef),
  #     group = c(rep("pearsPart", nrow(corrDF)), rep("GGM", nrow(corrDF)))
  #   )
  #
  # # plot to view the distribution of correlations
  # plot <-
  #   ggplot2.histogram(
  #     data = corrCoeff, xName = 'coef', groupName = 'group',
  #     legendPosition = "right", alpha = 0.5, binwidth = 0.01,
  #     brewerPalette = "Paired", addMeanLine = TRUE, meanLineSize = 1
  #   )
  #
  # plot <-
  #   ggplot2.customize(
  #     plot, xtitle = "Correlation coefficient", ytitle = "Count",
  #     showLegend = TRUE, axisLine = c(0.5, "solid", "black"),
  #     addDensity = TRUE, removePanelBorder = TRUE,
  #     backgroundColor = "white", mainTitle = "Correlation coefficient"
  #   )
  #
  # plot

  return(net)
}


# Function to make the multi-layer network by connecting the Genome-Scale
# Metabolic Network (GSMN) and the experimental networks
# INPUTS:
#  inputData   - list returned by the loadInputData function
#  expNetworks - list returned by the buildExpNet function
#  mappingF    - file in table format containing the mapping between the
#                metabolites from the  experimental networks and those from the
#                GSMN. Such mapping  can be obtained with tools such as
#                Metabolomics2Networks (see the MultiLayerNetwork vignette).
#                The file must contain at least 4 columns, separated by tabs:
#                "metabolite name" (name of the features from the peak list),
#                "mapped on id" (id of the corresponding metabolite from the
#                GSMN), "distance" (distance between the feature and its
#                corresponding metabolite. Note. The distance is equal to zero
#                when the mapping is exact), and "chebi" (ChEBI id of the
#                corresponding metabolite from the GSMN)
# OUTPUT: multi-layer network in list format containing 3 named elements:
#  "layers" (list of igraph objects), "type" (type of layer: Exp/GSMN),
#  "interLayerEdges" (data frame with 3 columns: expNode, gsmnNode, distance)
makeMultiLayer <- function(inputData, expNetworks, mappingF) {

  # read table
  mapping <- read.table(mappingF, header = TRUE, sep = "\t")

  # list of columns to keep
  colsToKeep <-  c("metabolite.name", "mapped.on.id", "distance")

  # filter list to keep only mapped nodes
  mappingFiltered <- mapping[mapping$mapped.on.id != "", colsToKeep]

  # create an empty data frame
  interLayerEdges <-
    data.frame(
      expNode = character(), gsmnNode = character(), distance = character()
      )

  # loop to collapse multiple mappings and get all the inter-layer edges
  for (i in seq_len(nrow(mappingFiltered))) {
    feat <- as.character(mappingFiltered[i, 1])
    met <- mappingFiltered[i, 2]
    dis <- mappingFiltered[i, 3]

    # split metabolite names and distances, if needed
    met <- unlist(str_split(str_remove(met, ";$"), ";"))
    dis <- unlist(str_split(str_remove(dis, ";$"), ";"))

    # add current inter-layer edges
    interLayerEdges <-
      rbind(
        interLayerEdges,
        data.frame(expNode = feat, gsmnNode = met, distance = dis)
        )
  }

  # make a multi-layer network with the GSMN and the experimental networks
  multiLayer <-
    list(
      layers = c(expNetworks, gsmn = list(inputData$gsmn)),
      type = c(rep("Exp", length(expNetworks)), "GSMN"),
      interLayerEdges = interLayerEdges
      )

  return(multiLayer)
}



# Function to calculate some statistics of the multi-layer network
# INPUTS:
#  multiLayer  - list returned by the makeMultiLayer function
# OUTPUT: none, but it creates several plots in the resPath directory
calculateMultiLayerStats <- function(multiLayer) {

  # verify if the results folder does not exist
  if (!file.exists(inputData$resPath)) {

    # create folder
    dir.create(inputData$resPath)
  }

  # make table of frequencies of the mapped GSMN nodes
  t <- makeFeqTable(multiLayer$interLayerEdges$gsmnNode, FALSE, "GSMN_node")

  # make plot
  makeBarPlot(
    resPath = inputData$resPath,
    data = t,
    xAxis = "GSMN_node",
    yAxis = "Freq",
    title = "GSMN nodes mapping frequency",
    vertical = FALSE
    )

  # make table of frequencies of the mapped GSMN nodes distances
  t <- makeFeqTable(multiLayer$interLayerEdges$distance, FALSE, "Distance")

  # make plot
  makeBarPlot(
    resPath = inputData$resPath,
    data = t,
    xAxis = "Distance",
    yAxis = "Freq",
    title = "Ontology distance of the mapped GSMN nodes",
    vertical = TRUE
  )

  return()
}


# Function to make a frequency table
# INPUTS:
#  data       - data to use
#  decreasing - if TRUE the frequencies will be sorted in descending order, or
#               in ascending order, otherwise
#  name       - name to give to the column where the values of the input data
#               will be stored
# OUTPUT: table of frequencies
makeFeqTable <- function(data, decreasing, name) {
  # make table of frequencies
  t <- as.data.frame(sort(table(data), decreasing = decreasing))
  colnames(t)[1] <- name

  return(t)
}



# Function to make and save a bar plot
# INPUTS:
#  resPath  - path to the folder where the results will be stored
#  data     - data frame containing the data to plot
#  xAxis    - column name of the data for the x-axis
#  yAxis    - column name of the data for the y-axis
#  title    - title of the plot
#  vertical - if TRUE, the bars will be vertical, otherwise, they will be
#             horizontal
# OUTPUT: none, but it saves the plot in the resPath directory
makeBarPlot <- function(resPath, data, xAxis, yAxis, title, vertical = TRUE) {
  # make plot
  p <-
    ggplot(
      data = data,
      aes(x = eval(as.symbol(xAxis)),
          y = eval(as.symbol(yAxis))
         )
      ) +
    geom_bar(stat = "identity") +
    ggtitle(title) +
    xlab(xAxis) +
    ylab(yAxis) +
    theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 16))

  # check orientation
  if (vertical == TRUE) {
    p <-
      p +
      geom_text(aes(label = eval(as.symbol(yAxis))), vjust = -0.3, size = 3.5)
  } else {
    p <-
      p +
      geom_text(
        aes(label = eval(as.symbol(yAxis))), hjust = -0.3, size = 3.5
        ) +
      coord_flip()
  }

  # save plot
  ggsave(
    paste0(resPath, str_replace_all(title, " ", "_"), ".png"),
    plot = p,
    dpi = 300
  )

  return()
}



# Function to save the list of edges and nodes from the multi-layer network
# to visualize it in Cytoscape
# INPUTS:
#   inputData  - list containing all the input data
#   multiLayer - list containing the multi-layer network
#   visualize  - if == TRUE, the multi-layer layer will be visualized in
#                Cytoscape (NOTE. Cytoscape needs to be open). The default
#                value is FALSE
# OUTPUT: nothing, but it generates files with the list of nodes, edges, and
#         the Cytoscape visualization (if visualize == TRUE)
saveMultiLayer <- function(inputData, multiLayer, visualize = FALSE) {
  # get list of edges
  allEdges <- getEdgeList(multiLayer)

  # save list of edges
  write.csv(
    allEdges,
    paste0(inputData$resPath, "MultiLayer4Cytoscape_EdgeList.csv"),
    row.names = FALSE,
    quote = FALSE
    )

  # get list of nodes
  allNodes <- getNodeList(multiLayer)

  # save list of nodes
  write.csv(
    allNodes,
    paste0(inputData$resPath, "MultiLayer4Cytoscape_NodeList.csv"),
    row.names = FALSE,
    quote = FALSE
    )

  if (visualize == TRUE) {
    # get inter-layer edges
    inter <- filterEdgesBySource(allEdges, "InterLayer")

    # get nodes connected by inter-layer edges
    nodes <- getNodesConnectedByEdges(inter, allNodes)

    # get all edges among the nodes that have  inter-layer edges
    edges <- getEdgesBetweenNodes(allEdges, nodes$node)

    # Cytoscape visualization
    cytoscapeVis(nodes, edges, inputData$resPath)
  }

  return()
}



# Function to filter a set of edges by a set of sources
# INPUTS:
#   edges   - data frame of edges containing 3 columns that correspond to the
#             first node, second node, and the type of interaction or source
#   sources - one or more sources in vector format
# OUTPUT: data frame of edges, filtered
filterEdgesBySource <- function(edges, sources) {
  return(edges[edges[[3]] %in% sources, ])
}


# Function to get the set of nodes connected by a given set of edges
# INPUT:
#   edges - data frame of edges containing 3 columns that correspond to the
#           first node, second node, and the type of interaction or source
#   nodes - data frame of two columns that correspond to the node name and its
#           type
# OUTPUT: vector of nodes
getNodesConnectedByEdges <- function(edges, nodes) {
  n <- unique(c(edges[[1]], edges[[2]]))

  return(nodes[nodes[[1]] %in% n, ])
}


# Function to get the set of edges connecting a given set of nodes
# INPUTS:
#   edges - data frame of edges containing 3 columns that correspond to the
#           first node, second node, and the type of interaction or source
#   nodes - set of nodes to filter the edges
# OUTPUT: data frame of edges, filtered
getEdgesBetweenNodes <- function(edges, nodes) {
  return(edges[edges[[1]] %in% nodes & edges[[2]] %in% nodes, ])
}

# Function to get the list of edges in a multi-layer network
# INPUT: multi-layer network
# OUTPUT: list of edges, including inter-layer ones
getEdgeList <- function(multiLayer) {
  allEdges <-
    data.frame(
      node1 = character(),
      node2 = character(),
      source = character()
      )

  # get edge list of all the networks and paste it in a single data frame
  for (i in seq_len(length(multiLayer$layers))) {

    # get edge list
    edges <- as_edgelist(multiLayer$layers[[i]])

    # add to general list
    allEdges <-
      rbind(
        allEdges,
        data.frame(
          node1 = edges[, 1],
          node2 = edges[, 2],
          source =
            paste(multiLayer$type[i], names(multiLayer$layers)[i], sep = "_")
          )
        )
  }

  # add inter-layer edges
  allEdges <-
    rbind(
      allEdges,
      data.frame(
        node1 = multiLayer$interLayerEdges[, 1],
        node2 = multiLayer$interLayerEdges[, 2],
        source = "InterLayer"
      )
    )

  return(allEdges)
}



# Function to get the list of nodes in a multi-layer network
# INPUT: multi-layer network
# OUTPUT: list of nodes
getNodeList <- function(multiLayer) {
  # get types of layers
  type <- unique(multiLayer$type)

  # initialize empty variables
  nodes <- list()
  nodeType <- list()

  # loop through the types of layers
  for (t in type) {
    # get nodes from current type
    n <-
      unique(
        unlist(
          lapply(
            multiLayer$layers[multiLayer$type == t],
            function(X) {
              names(V(X))
              }
            )
          )
        )

    # add nodes to the list
    nodes <- c(nodes, n)

    # add node type
    nodeType <- c(nodeType, rep(t, length(n)))
  }

  # create data frame
  allNodes <-
    data.frame(
      node = unlist(nodes),
      nodeType = unlist(nodeType)
    )

  return(allNodes)
}


# Definition of a function to visualize in Cytoscape the subnetworks of the
# experimental nodes that map to the same metabolite node in the GSMN.
# NOTE. Cytoscape needs to be open
# INPUTS:
#   allNodes    - list of nodes
#   allEdges    - list of edges
#   resPath     - path where the results will be stored
#   mainType    - a subnetwork will be generated for each of the nodes from
#                 this node type so that can observe the connection patterns
#                 between the different edges connecting all the nodes from the
#                 other types that map to each of the nodes from the main type.
#                 The default value is "GSMN"
#   fixedColors - boolean value (TRUE/FALSE), if == TRUE, a set of predefined
#                 colors will be used to style the nodes and edges, as follows:
#                 NODES: {blue = experimental, orange = GSMN},
#                 EDGES: {yellow = correlation, orange = mass difference,
#                         green = spectral similarity, black = GSMN,
#                         blue = inter-layer}.
#                 If fixedColors == FALSE, the colors of the nodes and edges
#                 will be assigned automatically. The default value is TRUE
# OUTPUT: None, but it generates a Cytoscape file with the visualization
cytoscapeVis <-
  function(nodes, edges, resPath, mainType = "GSMN", fixedColors = TRUE) {
    # verify that Cytoscape is launched
    cytoscapePing()

    # close any open session
    closeSession(save.before.closing = FALSE)

    # change column names to match the requirements of RCy3
    colnames(edges) <- c("source", "target", "interaction")

    # create aggregated version of the multi-layer network
    aggregated <-
      graph_from_data_frame(edges, directed = FALSE, vertices = nodes)

    # visualize aggregated network
    visualizeNetwork(
      aggregated, title = "MultiLayer", collection = "MultiLayerNetwork",
      fixedColors = fixedColors
      )

    # get inter-layer edges and nodes connected by them
    inter <- filterEdgesBySource(edges, sources = "InterLayer")

    # get nodes connected by inter-layer edges
    nodesIL <- getNodesConnectedByEdges(inter, nodes)

    # get nodes from main node type
    nodesILT <- nodes[nodes$nodeType == mainType, ]

    # loop to generate sub-networks
    for (n in nodesILT$node) {
      # get edges connecting current node
      curEd <- edges[edges$target == n | edges$source == n, ]

      # remove edges from main type
      omit <- grep(mainType, curEd$interaction)
      if (length(omit) > 0) {
        curEd <-  curEd[-omit, ]
      }

      # get list of all nodes connected to current node
      nCon <- unique(c(curEd$source, curEd$target))

      # create subnetwork
      subnet <-
        subgraph(aggregated, vids = which(names(V(aggregated)) %in% nCon))

      # visualize subnetwork
      visualizeNetwork(
        subnet, title = paste0(n, "_AllLayers"), collection = n,
        fixedColors = fixedColors
      )

      # get types of edges connecting the nodes of current subnetwork
      edgeTypes <- as.vector(unique(edge_attr(subnet, "interaction")))

      # remove inter-layer edges
      edgeTypes <- edgeTypes[- which(edgeTypes == "InterLayer")]

      # loop to generate a subnetwork per edge type
      for(eType in edgeTypes) {
        # select edges of current type
        selectEdges(
          edges = eType,
          by.col = "interaction",
          preserve.current.selection = FALSE,
          network = paste0(n, "_AllLayers")
        )

        # select all nodes connected by selected edges
        selectNodesConnectedBySelectedEdges(network = paste0(n, "_AllLayers"))

        # create subnetwork
        createSubnetwork(
          nodes = "selected",
          edges = "selected",
          subnetwork.name = paste0(n, "_", eType),
          network = paste0(n, "_AllLayers"),
        )

        layoutNetwork(
          layout.name = "force-directed", network = paste0(n, "_", eType))
      }
    }

    return()
  }



# Function to create and visualize in Cytoscape the aggregated network
# INPUTS:
#   network     - igraph object containing the network to visualize
#   title       - title (name) of the network to be displayed in Cytoscape
#   collection  - collection the network will belong to
#   fixedColors - boolean value (TRUE/FALSE), if == TRUE, a set of predefined
#                 colors will be used to style the nodes and edges, as follows:
#                 NODES: {blue = experimental, orange = GSMN},
#                 EDGES: {yellow = correlation, orange = mass difference,
#                         green = spectral similarity, black = GSMN,
#                         blue = inter-layer}.
#                 If fixedColors == FALSE, the colors of the nodes and edges
#                 will be assigned automatically
# OUTPUT: aggregated network
visualizeNetwork <- function(network, title, collection, fixedColors) {

  # create network in Cytoscape
  createNetworkFromIgraph(
    network,
    title = title,
    collection = collection
  )

  # get types of nodes and edges in the network
  nodeTypes <- unique(get.vertex.attribute(network, "nodeType"))
  edgeTypes <- unique(get.edge.attribute(network, "interaction"))

  # get colors to use
  colors <- getColorTable(nodeTypes, edgeTypes, fixedColors)

  # color the nodes
  setNodeColorMapping(
    table.column = "nodeType", table.column.values = nodeTypes,
    colors =
      sapply(
        nodeTypes,
        function(X) {
          colors$color[colors$type == "Node" & colors$name == X]
          }
        ),
    mapping.type = "d", network = title
    )

  # color the edges
  setEdgeColorMapping(
    table.column = "interaction", table.column.values = edgeTypes,
    colors =
      sapply(
        edgeTypes,
        function(X) {
          colors$color[colors$type == "Edge" & colors$name == X]
        }
      ),
    mapping.type = "d", network = title
  )

  layoutNetwork(layout.name = "force-directed", network = title)

  return()
}



# Function to get the table of colors for the nodes and edges
# INPUTS:
#   nodeTypes   - types of nodes in the network to color
#   edgeTypes   - types of edges in the network to color
#   fixedColors - whether to return fixed colors or not
# OUTPUT:
#   data frame of three columns: type, name, and color, containing the colors
#   for the nodes and edges
getColorTable <- function(nodeTypes, edgeTypes, fixedColors) {
  # check whether predefined list of colors is to be used
  if (fixedColors == TRUE) {
    colors <-
      data.frame(
        type = c(rep("Edge", 5), rep("Node", 2)),
        name = c("Exp_c", "Exp_m", "Exp_s", "GSMN_gsmn", "InterLayer", "Exp",
                 "GSMN"),
        # code colors:
        #   #F0E442 = yellow edges (Exp_c), #D55E00 = orange edges (Exp_m),
        #   #009E73 = green edges (Exp_s), #000000 = black edges (GSMN_gsmn),
        #   #0072B2 = blue edges (InterLayer), #56B4E9 = blue nodes (Exp),
        #   #E69F00 = orange nodes (GSMN)
        color = c("#F0E442", "#D55E00", "#009E73", "#000000", "#0072B2",
                  "#56B4E9", "#E69F00")
      )
  } else { # set the colors automatically
    # get number of types of edges and nodes
    edgeTypesNo <- length(edgeTypes)
    nodeTypesNo <- length(nodeTypes)

    # pick blind-color friendly colors
    palette <-
      palette.colors(palette = "Okabe-Ito")[1:(edgeTypesNo + nodeTypesNo)]

    # make data frame with the colors for each type of node and edge
    colors <-
      data.frame(
        type = c(rep("Edge", edgeTypesNo), rep("Node", nodeTypesNo)),
        name = c(edgeTypes, nodeTypes),
        color = palette
      )
  }

  return(colors)
}


formatNodesAndEdges <- function(Network, d, LoadedData, DE) {
  numberOfLayers <- length(LoadedData$DensityPerLayerMultiplex)

  # if there are 3 layers, use the same edges' colors as in the paper
  if(numberOfLayers == 3) {
    edgesColors <- c("#0033FF", "#FF6600", "#FFFF00")
  } else { # otherwise, generate a list of colors of the appropriate size
    edgesColors <- rainbow(length(LoadedData$DensityPerLayerMultiplex))

    # remove "transparency" from colors (i.e., the last 2 characters)
    edgesColors <-
      unlist(lapply(edgesColors, function(X){ substr(X, 1, 7) }))
  }

  # define edges color (it is adapted to any number of layers)
  setEdgeColorMapping(table.column = "interaction", mapping.type = "d",
                      table.column.values = unique(Network$interaction), colors = edgesColors)

  if ("logFC" %in% colnames(DE)) {
    # set nodes' colors according to the logFC, from green (downregulated)
    # to white and then to red (upregulated)
    setNodeColorMapping(
      table.column = "logFC", table.column.values = c(min(DE$logFC),
                                                      0.0, max(DE$logFC)), colors = c("#009933", "#FFFFFF", "#FF0000"),
      mapping.type = "c", style.name = "default", network = d)
  }

  setNodeBorderColorMapping(table.column = "name", colors = "#000000",
                            mapping.type = "d", style.name = "default", default.color = "#000000",
                            network = d)

  # set width of border to highlight DEG
  setNodeBorderWidthMapping(table.column = "DEG",
                            table.column.values = c(TRUE, FALSE), widths = c(5, 0),
                            mapping.type = "d", style.name = "default", network = d)

}




