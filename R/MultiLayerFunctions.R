library(MetClassNetR)
library(MetNet)
library(Spectra)
library(MsCoreUtils)
library(MsBackendMgf)
library(easyGgplot2)
library(QFeatures)
library(igraph)
library(tidyverse)
library(reticulate)
library(dplyr)
library(muxViz)
library(ggplot2)
library(stringr)
library(reticulate)

# Function to load the input data, i.e., the files needed to build the networks
# INPUTS:
# peakListF -  path to the TSV file that contains the peak list (one peak per 
#              row) in a MetaboLights-like format. The first row is the header
#              (i.e., the list of columns' names). The file should contain at
#              least 3 columns: "database_identifier" (ChEBI), "mass_to_charge",
#              and "retention_time". It is to note that these column names are 
#              fixed. The TSV file can also contain intensity (or abundance)
#              values. In this case, the column names are free (e.g., can be 
#              named after the samples), but no blank spaces are allowed and
#              the first character must be a letter. In addition, all the 
#              abundances must be placed at the end of the table, i.e., in the
#              last columns
#  intCol -    number of the first column containing the intensities or of the 
#              subset of columns to take the intensity values from. The default
#              value is 23, as in all datasets available in MetaboLights
#              (https://www.ebi.ac.uk/metabolights)
#  transF -    (optional) path to the CSV file containing the transformation 
#              list. It must contain at  least the columns "name", "formula", 
#              and "mass". This file is needed if the mass difference network 
#              is to be built 
#  spectraF -  (optional) path to the MSMS data in MGF format, if available
#  gsmnF -     path to the compound graph in GML format, as generated by Met4J 
#              (https://forgemia.inra.fr/metexplore/met4j). The compound graphs
#              of some organisms are available in the data folder
#  spectraSS - (optional) samples the spectra dataset, according to the given 
#              sample size. This would speed up the process and it is useful
#              when testing your data and/or this package
#  resPath   - path to the folder where the results will be stored
# OUTPUT:      named list containing all the data (peakList, spectra, 
#              transformations, and gsmn)
LoadInputData <- 
  function (
    peakListF, intCol = 23, net2Build = "all", transF, spectraF, gsmnF,
    spectraSS = NULL, resPath
    ) {
  peakList <- readMaf(peakListF, ecol = intCol) # read peak list
  data <- read_tsv(peakListF) # read peak list file

  # keep only identified metabolites
  identifiedMet <- 
    data[!is.na(data$database_identifier), c("id", "database_identifier")]
  
  # read fragmentation spectra
  spectra <- 
    Spectra(spectraF, source = MsBackendMgf(), backend = MsBackendDataFrame())

  # check if sampling is to be done
  if (!is.null(spectraSS)) {
    if (spectraSS < length(spectra)) { # sample size < current spectra size?
      keep <- sample(seq_len(length(spectra)), spectraSS) # sample
      spectra <- spectra[keep]      
    }
  }
  
  transformations <- read_csv(transF, col_names = TRUE) # read transformations
  gsmn <- read_graph(gsmnF, format = "gml") # read GSMN
  labels <- 
    unlist(
      lapply(get.vertex.attribute(gsmn, "label"), function(X) {
        n <- nchar(X)
        substr(X, 1, n-2)
      }
      )
    )
  gsmn <- set.vertex.attribute(gsmn, name = "name", value = labels)

  # sanity checks  
  if (!checkQFeatures(peakList)) {
    stop(paste0("Bad peak list. Please check your file ", peakListF))
  } else if (!checkSpectra(spectra)) {
    stop(paste0("Bad spectra. Please check your file ", spectra))
  } else { # if the sanity checks are OK, return the read data
    return (
      list(
        peakList = peakList, 
        allComp = data$id,
        identifiedMet = identifiedMet,
        spectra = spectra, 
        transformations = transformations, 
        gsmn = gsmn, 
        resPath = resPath
        ) 
      )
  }
}

# Function to build experimental networks, based on spectral similarity, 
# correlation, and mass difference
# INPUTS:
#  inputData - list returned by the LoadInputData function
#  net2Build - list of experimental networks to build, according to the 
#              following options: 
#               "all" - generates 3 experimental networks: mass difference,
#                     correlation, and spectral similarity,
#               "m" - builds the mass difference network,
#               "s" - builds the spectral similarity network,
#               "c" - builds the correlation network.
#              It is to note that combinations of m, s, and c are possible,
#              writing them separated by commas, e.g., c("m", "c") would 
#              generate the mass difference and correlation networks. The 
#              default value is "all"
#  directed  - boolean value (TRUE/FALSE). If TRUE then the networks that are
#              generated will be directed, and undirected otherwise. The 
#              default value is FALSE (i.e., undirected network)
#  ppmMass   - allowed error for mass differences calculus. It is only needed
#              if the mass difference network is to be built. The default value
#              is 10
#  ppmSpec   - relative allowed error for spectral similarity calculus. It is 
#              only needed if the spectral similarity network is to be built.  
#              The default value is 0
#  tol       - absolute tolerance for spectral similarity calculus. It is only 
#              needed if the spectral similarity network is to be built. The  
#              default value is 0.005  
#  corrModel - character vector containing the model(s) to be used for the 
#              correlation calculus. There are 11 models available: "lasso", 
#              "randomForest", "clr", "aracne", "pearson", "pearson_partial", 
#              "pearson_semipartial", "spearman", "spearman_partial", 
#              "spearman_semipartial", and "bayes". This parameter is only 
#              needed if the correlation network is to be built. The default
#              value is "pearson"
# corrThresh - floating point number indicating the correlation threshold to 
#              consider that two features are correlated. It is only needed if 
#              the correlation network is to be built. The default value is 
#              0.25 (i.e., at least 25% of correlation between the abundance
#              values, either positive or negative)
# OUTPUT: list of experimental networks as igraph objects
BuildExpNet <- 
  function(
    inputData, net2Build = "all", directed = FALSE, ppmMass = 10, ppmSpec = 0,
    tol = 0.005, corrModel = "pearson", corrThresh = 0.25) {

    # empty list to save the experimental networks 
    expNet <- list()
  
    # check if mass difference network is to be built
    if (any(c("m", "all") %in% net2Build)) {
      # build mass difference network
      res <- BuildMassDiffNet(inputData, ppmMass, directed)
      
      # add network to the list
      expNet[["m"]] <- res$net
      
      # save the mass difference matrix
      massDiff <- res$massDiff
    }
    
    # check if spectral similarity network is to be built
    if (any(c("s", "all") %in% net2Build)) {
      # check if the mass difference matrix does not already exists
      if (!exists("massDiff")) {
        # build mass difference network
        res <- BuildMassDiffNet(inputData, ppmMass, directed)
        
        # save the mass difference matrix
        massDiff <- res$massDiff
      }
      
      # build spectral similarity network
      net <- BuildSpecSimNet(inputData, tol, ppmSpec, massDiff, directed)
      
      # add network to the list
      expNet[["s"]] <- net
    }
    
    # check if correlation network is to be built
    if (any(c("c", "all") %in% net2Build)) {
      # build correlation network
      net <- BuilCorrNet(inputData, directed, corrModel, corrThresh)
      
      # add network to the list
      expNet[["c"]] <- net
    }    
    
    return(expNet)
  }


# Function to build the mass difference network
# INPUTS:
#  inputData - list returned by the LoadInputData function
#  ppmMass   - allowed error for mass differences calculus
#  directed  - boolean value (TRUE/FALSE). If TRUE then the networks that are
#              generated will be directed, and undirected otherwise. The 
#              default value is FALSE (i.e., undirected network)
# OUTPUT: mass difference network as igraph object
BuildMassDiffNet <- function(inputData, ppmMass, directed) {
  # create mass difference adjacency matrix
  massDiff <- 
    qfeat_structural(
      x = inputData$peakList,  
      assay_name = names(inputData$peakList),
      transformation = inputData$transformations,
      var = c("name", "formula", "mass"),
      ppm = ppmMass
    )
  
  # add row data
  rowData(massDiff) <- 
    as.data.frame(rowData(inputData$peakList[[names(inputData$peakList)]]))

  # get edges from the adjacency matrix
  massDiffDF <- as.data.frame(massDiff) |> filter(binary == 1)
  
  # create igraph object
  net <- 
    graph_from_data_frame(
      massDiffDF, 
      directed = directed, 
      vertices = inputData$allComp
      )
  
  return(list(net = net, massDiff = massDiff))
}


# Function to build the spectral similarity network
# INPUTS:
#  inputData - list returned by the LoadInputData function
#  tol       - absolute tolerance for spectral similarity calculus
#  ppmSpec   - relative allowed error for spectral similarity calculus. It is 
#              only needed if the spectral similarity network is to be built.  
#              The default value is 0
#  massDiff   - mass difference adjacency matrix as generated by MetNet
#  directed  - boolean value (TRUE/FALSE). If TRUE then the networks that are
#              generated will be directed, and undirected otherwise. The 
#              default value is FALSE (i.e., undirected network)
# OUTPUT: spectral similarity network as igraph object
BuildSpecSimNet <- function(inputData, tol, ppmSpec, massDiff, directed) {
  # calculate spectral similarity
   spectralSim <- 
    spec_molNetwork(
      inputData$spectra, MAPFUN = joinPeaksGnps, methods = "gnps",
      tolerance = tol, ppm = ppmSpec, type = "inner"
    )
  
  # add spectral similarity to the structural adjacency matrix from MetNet
  spectralSimA <- 
    addSpectralSimilarity(
      am_structural = massDiff, ms2_similarity = spectralSim
      )
  
  # get edges from the adjacency matrix
  spectralSimDF <- as.data.frame(spectralSimA) |> filter(!is.na(gnps)) |>
    filter(binary == 1) |> filter(Row != Col)
       
  # create igraph object
  net <- 
    graph_from_data_frame(
      spectralSimDF, 
      directed = directed, 
      vertices = inputData$allComp
      )
  
  return(net)
}


# Function to build the correlation network 
# INPUTS:
#  inputData - list returned by the LoadInputData function
#  directed  - boolean value (TRUE/FALSE). If TRUE then the networks that are
#              generated will be directed, and undirected otherwise. The 
#              default value is FALSE (i.e., undirected network)
#  corrModel - character vector containing the model(s) to be used for the 
#              correlation calculus
# corrThresh - floating point number indicating the correlation threshold to 
#              consider that two features are correlated
# OUTPUT: correlation network as igraph object
BuilCorrNet <- function(inputData, directed, corrModel, corrThresh) {
  # calculate correlation 
  corr <- 
    qfeat_statistical(
      x = inputData$peakList,
      assay_name = names(inputData$peakList), 
      model = corrModel,
      na.omit = TRUE,
      p.adjust = "BH"
    )
  
  # get edges from the adjacency matrix
  corrDF <- as.data.frame(corr)
  
  # filter correlation to keep only those above threshold
  corrDF <- corrDF[abs(corrDF$pearson_partial_coef) >= corrThresh, ]
  
  # create igraph object
  net <- 
    graph_from_data_frame(
      corrDF, 
      directed = directed, 
      vertices = inputData$allComp
      )
  
  # # save correlation coefficients 
  # corrCoeff <- 
  #   data.frame(
  #     coef = c(corrDF$pearson_partial_coef, corrDF$ggm_coef),
  #     group = c(rep("pearsPart", nrow(corrDF)), rep("GGM", nrow(corrDF)))
  #   )
  # 
  # # plot to view the distribution of correlations 
  # plot <- 
  #   ggplot2.histogram(
  #     data = corrCoeff, xName = 'coef', groupName = 'group', 
  #     legendPosition = "right", alpha = 0.5, binwidth = 0.01, 
  #     brewerPalette = "Paired", addMeanLine = TRUE, meanLineSize = 1
  #   )
  # 
  # plot <-
  #   ggplot2.customize(
  #     plot, xtitle = "Correlation coefficient", ytitle = "Count",
  #     showLegend = TRUE, axisLine = c(0.5, "solid", "black"),
  #     addDensity = TRUE, removePanelBorder = TRUE, 
  #     backgroundColor = "white", mainTitle = "Correlation coefficient"
  #   )   
  # 
  # plot
  
  return(net)
}


# Function to make the multi-layer network by connecting the Genome-Scale 
# Metabolic Network (GSMN) and the experimental networks 
# INPUTS:
#  inputData   - list returned by the LoadInputData function
#  expNetworks - list returned by the BuildExpNet function
#  mappingF    - file in table format containing the mapping between the 
#                metabolites from the  experimental networks and those from the 
#                GSMN. Such mapping  can be obtained with tools such as  
#                Metabolomics2Networks (see the MultiLayerNetwork vignette). 
#                The file must contain at least 4 columns, separated by tabs:
#                "metabolite name" (name of the features from the peak list), 
#                "mapped on id" (id of the corresponding metabolite from the 
#                GSMN), "distance" (distance between the feature and its 
#                corresponding metabolite. Note. The distance is equal to zero 
#                when the mapping is exact), and "chebi" (ChEBI id of the
#                corresponding metabolite from the GSMN)
# OUTPUT: multi-layer network in list format containing 3 named elements:
#  "layers" (list of igraph objects), "type" (type of layer: Exp/GSMN), 
#  "interLayerEdges" (data frame with 3 columns: expNode, gsmnNode, distance)
MakeMultiLayer <- function(inputData, expNetworks, mappingF) {
  # read table
  mapping <- read.table(mappingF, header = TRUE, sep = "\t")

  # list of columns to keep
  colsToKeep <-  c("metabolite.name", "mapped.on.id", "distance")
  
  # filter list to keep only mapped nodes
  mappingFiltered <- mapping[mapping$mapped.on.id != "", colsToKeep]
  
  # create an empty data frame
  interLayerEdges <- 
    data.frame(
      expNode = character(), gsmnNode = character(), distance = character()
      )
  
  # loop to collapse multiple mappings and get all the inter-layer edges
  for (i in seq_len(nrow(mappingFiltered))) {
    feat <- as.character(mappingFiltered[i, 1])
    met <- mappingFiltered[i, 2]
    dis <- mappingFiltered[i, 3]
    
    # split metabolite names and distances, if needed
    met <- unlist(str_split(str_remove(met, ";$"), ";"))
    dis <- unlist(str_split(str_remove(dis, ";$"), ";"))

    # add current inter-layer edges
    interLayerEdges <- 
      rbind(
        interLayerEdges, 
        data.frame(expNode = feat, gsmnNode = met, distance = dis)
        )
  }
  
  # make a multi-layer network with the GSMN and the experimental networks
  multiLayer <- 
    list(
      layers = c(expNetworks, gsmn = list(inputData$gsmn)), 
      type = c(rep("Exp", length(expNetworks)), "GSMN"),
      interLayerEdges = interLayerEdges
      )
  
  return(multiLayer)
}



# Function to calculate some statistics of the multi-layer network
# INPUTS:
#  multiLayer  - list returned by the MakeMultiLayer function
# OUTPUT: none, but it creates several plots in the resPath directory
CalculateMultiLayerStats <- function(multiLayer) {
  # verify if the results folder does not exist
  if (!file.exists(inputData$resPath)) {
    # create folder
    dir.create(inputData$resPath)
  }
  
  # make table of frequencies of the mapped GSMN nodes
  t <- MakeFeqTable(multiLayer$interLayerEdges$gsmnNode, FALSE, "GSMN_node")

  # make plot
  MakeBarPlot(
    resPath = inputData$resPath, 
    data = t, 
    xAxis = "GSMN_node", 
    yAxis = "Freq", 
    title = "GSMN nodes mapping frequency", 
    vertical = FALSE
    )
  
  # make table of frequencies of the mapped GSMN nodes distances
  t <- MakeFeqTable(multiLayer$interLayerEdges$distance, FALSE, "Distance")

  # make plot
  MakeBarPlot(
    resPath = inputData$resPath, 
    data = t, 
    xAxis = "Distance", 
    yAxis = "Freq", 
    title = "Ontology distance of the mapped GSMN nodes", 
    vertical = TRUE
  )

  return()
}


# Function to make a frequency table 
# INPUTS:
#  data       - data to use 
#  decreasing - if TRUE the frequencies will be sorted in descending order, or
#               in ascending order, otherwise 
#  name       - name to give to the column where the values of the input data 
#               will be stored
# OUTPUT: table of frequencies
MakeFeqTable <- function(data, decreasing, name) {
  # make table of frequencies 
  t <- as.data.frame(sort(table(data), decreasing = decreasing))
  colnames(t)[1] <- name
  
  return(t)
}



# Function to make and save a bar plot
# INPUTS:
#  resPath  - path to the folder where the results will be stored
#  data     - data frame containing the data to plot
#  xAxis    - column name of the data for the x-axis
#  yAxis    - column name of the data for the y-axis
#  title    - title of the plot
#  vertical - if TRUE, the bars will be vertical, otherwise, they will be 
#             horizontal
# OUTPUT: none, but it saves the plot in the resPath directory
MakeBarPlot <- function(resPath, data, xAxis, yAxis, title, vertical = TRUE) {
  # make plot
  p <- 
    ggplot(
      data = data, 
      aes(x = eval(as.symbol(xAxis)), 
          y = eval(as.symbol(yAxis))
         )
      ) + 
    geom_bar(stat = "identity") + 
    ggtitle(title) + 
    xlab(xAxis) + 
    ylab(yAxis) + 
    theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 16))
  
  # check orientation
  if (vertical == TRUE) {
    p <- 
      p + 
      geom_text(aes(label = eval(as.symbol(yAxis))), vjust = -0.3, size = 3.5) 
  } else {
    p <- 
      p + 
      geom_text(aes(label = eval(as.symbol(yAxis))), hjust = -0.3, size = 3.5) + 
      coord_flip() 
  }
  
  # save plot
  ggsave(
    paste0(resPath, str_replace_all(title, " ", "_"), ".png"), 
    plot = p,
    dpi = 300
  )

  return()  
}
