---
title: "MultiLayer"
author: "Elva Novoa"
date: '2022-09-07'
output: pdf_document
---

```{r setup, message=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(MetClassNetR)
library(MsCoreUtils)
library(tidyverse)
library(dplyr)
library(QFeatures)
```

# Buildig a multi-layer network

This vignette generates up to three experimental networks and connects them 
to a Genome-Scale Metabolic Network (GSMN) using the ChEBI ontology tree 
(`Metabolomics2Network` Python package). If an exact match is found, the 
distance between the metabolites is zero, and it can be higher or lower than 
zero, depending if the metabolite is mapped to a more general metabolite 
(parent class) or to a more specific metabolite (child).

Please note that you must have Python installed, and also the 
following packages: 
 - `Metabolomics2Network` 
 (download it from https://forgemia.inra.fr/metexplore/metabolomics2network)
 - `libchebipy` 
 - `urllib3`
 - `Sphinx`
 - `sphinxcontrib-napoleon`


## Load input data 

The first step in this workflow is to load the input data, using the 
`loadInputData` function. Input Parameters are described in detail in the documentation.

The output of the `loadInputData` function is a named list containing all the  
data (i.e., peakList, spectra, transformations, and gsmn).

```{r loadData}
# load("../VariablesFromVignette.RData")
path <- "extdata/MTBLS1586/"
exp <- "MTBLS1586_LC-MS_positive_reverse-phase_metabolite_profiling"

inputData <- 
  loadInputData(
    peakListF = 
      system.file(
        paste0(path, "m_", exp, "_v2_maf.tsv"), 
        package = "MetClassNetR"
        ), 
    intCol = 23, 
    transF = 
      system.file(
        paste0(path, "transformations_MTBLS1586.csv"), 
        package = "MetClassNetR"
        ),
    spectraF = 
      system.file(
        paste0(path, "ms2_", exp, ".mgf"), 
        package = "MetClassNetR"
        ), 
    gsmnF = 
      system.file(
        paste0(path, "WormJam-GEM-20190101_L3_no-side_no-comp.gml"), 
        package = "MetClassNetR"
        ),  
    resPath = "~/MetClassNetR_MultiLayerNetwork/", 
    met2NetDir = 
      paste0(
        find.package("MetClassNetR"), 
        "/Python/metabolomics2network-master/"
        ),
    configF =  
      system.file(
        paste0(path, "Metabolomics2NetworksData/JsonConf.txt"), 
        package = "MetClassNetR"
        ),
    idenMetF =  
      system.file(
        paste0(
          path, 
          "Metabolomics2NetworksData/IdentifiedMet_", 
          exp, 
          "_v2_maf.tsv"
          ), 
        package = "MetClassNetR"
        ),
    metF = 
      system.file(
        paste0(path, "WormJamMet_2019.tsv"), 
        package = "MetClassNetR"
        ), 
    spectraSS = 50,
    fixSpectra = TRUE,
    cleanMetF = FALSE
    ) 

```

## Build experimental networks

The second step is to build up to three experimental networks, based on 
spectral similarity, correlation, and mass difference. We build
the experimental networks using the `buildExpNet` function. This will
take some minutes depending on your system.

The output of the `buildExpNet` function is a list of experimental networks as 
igraph objects.

```{r buildNetworks}
expNetworks <-
  buildExpNet(
    inputData, 
    net2Build = "all", 
    directed = FALSE, 
    ppmMass = 10, 
    ppmSpec = 0,
    tol = 0.005, 
#    corrModel = "pearson_partial",
    corrModel = "pearson",
    corrThresh = 0.25
    )

```


## Map identified metabolites to the GSMN 

The third step is to map the manually identified features to the corresponding 
metabolites in the GSMN, using the ChEBI id of such features. Notably, although
it is possible to do exact matching and potentially have a low covering (i.e., 
to have very few matches since not all the metabolites participate in known
chemical reactions of a GSMN), we could also use ontologies (such as ChEBI) and 
maximize the covering. 

```{r mapping}

## Metabolomics2Network
resFile <- "Res_Met2Net_MappedMet.txt"

mapMetToGSMN(inputData, resFile, method="metabolomics2network")
```

Finally, we are ready to finish building the multi-layer network, joining the 
experimental networks with the GSMN, thanks to the mappings we just obtained. 
To this end, we call the `makeMultiLayer` function with the `inputData` object,
the experimental networks (stored in `expNetworks`), and the path to the folder 
that contains the mappings, which is called `GMSNMappings`, and it is located
inside `inpuData$resPath`. 

In order to visualize and/or save the multi-layer network as two files: one
containing the list of edges and another one with the list of nodes, we call 
the `writeMultiLayer` function with the `inputData` and `multiLayer` objects, 
and a boolean value for the parameter `visualize` that should be `TRUE` if 
the multi-layer network is to be visualized in Cytoscape or `FALSE` otherwise. 
Please be aware that Cytoscape should be open if `visualize == TRUE`.


```{r multiLayer}
pathToMappings <- paste0(inputData$resPath, "GSMNMappings/")

multiLayer <- makeMultiLayer(inputData, expNetworks, pathToMappings)

writeMultiLayer(inputData, multiLayer, visualize = FALSE)
```


# Analyzing the multi-layer network

As a final step, we will analyze the interconnection level between the 
experimental layers and the GSMN of the multi-layer network. For that, we will 
calculate some basic stats, using the `calculateMultiLayerStats` function, 
which generates some plots and stores them in the `resPath` directory (defined
in `inputData`.


```{r multiLayerStats}
calculateMultiLayerStats(multiLayer, inputData)
```

```{r}
sessionInfo()
```

