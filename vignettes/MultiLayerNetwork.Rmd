---
title: "MultiLayer"
author: "Elva Novoa"
date: '2022-04-25'
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

#source(file = "../R/multiLayer.R")
source(file = "/home/elva/Documents/MetClassNet/R/MetClassNetR_devel_liesa_Elva/R/MultiLayerFunctions.R")

```

# Buildig a multi-layer network

This vignette generates up to three experimental networks and connects them 
to a Genome-Scale Metabolic Network (GSMN) using the ChEBI ontology tree 
(`Metabolomics2Network` Python package). If an exact match if found, the 
distance between the metabolites is zero, and it can be higher or lower than 
zero, depending if the metabolite is mapped to a more general metabolite 
(parent class) or to a more specific metabolite (child).

## Load input data 

The first step in this workflow is to load the input data, using the 
`loadInputData` function, which has up to 7 input parameters:

1. `peakListF`. Path to the TSV file containing the peak list (one peak per row) 
   in a MetaboLights-like format. The first row is the header (i.e., the list of 
   columns' names). The file should contain at least 3 columns: 
   "database_identifier" (ChEBI),  "mass_to_charge", and "retention_time". It 
   is to note that these column names are fixed. The TSV file can also contain
   intensity (or abundance) values. In this case, the column names are free 
   (e.g., can be named after the samples), but no blank spaces are allowed and 
   the first character must be a letter. In addition, all the abundances must 
   be placed at the end of the table, i.e., in the last columns. 
2. `intCol`. Number of the first column containing the intensities. The default
   value is 23, as in all datasets available in MetaboLights 
   (https://www.ebi.ac.uk/metabolights/).
3. `transF`. (Optional) Path to the CSV file containing the transformation list. 
   It must have at  least the columns "name", "formula", and "mass". This file  
   is needed if the mass difference network is to be built.
4. `spectraF`. (Optional) Path to the MSMS data in MGF format, if available.
5. `gsmnF`. Path to the compound graph in GML format, as generated by Met4J 
   (https://forgemia.inra.fr/metexplore/met4j). The compound graphs of some
   organisms are available in the data folder.
6. `spectraSS`. (Optional) Reduces the spectral dataset to the selected
    sample size to speed up the generation of the report when testing the 
    MetClassNetR package.
7. `resPath`. Path to the folder where the results will be stored

The output of the `loadInputData` function is a named list containing all the  
data (i.e., peakList, spectra, transformations, and gsmn).

```{r loadData}
# load("../VariablesFromVignette.RData")
path <- "extdata/MTBLS1586/"
exp <- "MTBLS1586_LC-MS_positive_reverse-phase_metabolite_profiling"

inputData <- 
  loadInputData(
    peakListF = 
      system.file(
        paste0(path, "m_", exp, "_v2_maf.tsv"), 
        package = "MetClassNetR"
        ), 
    intCol = 23, 
    net2Build = "all", 
    transF = 
      system.file(
        paste0(path, "transformations_MTBLS1586.csv"), 
        package = "MetClassNetR"
        ),
    spectraF = 
      system.file(
        paste0(path, "ms2_", exp, ".mgf"), 
        package = "MetClassNetR"
        ), 
    gsmnF = 
      system.file(
        paste0(path, "WormJam-GEM-20190101_L3_no-side_no-comp.gml"), 
        package = "MetClassNetR"
        ), 
    resPath = "~/MetClassNetR_MultiLayerNetwork/" #, 
#    spectraSS = 50
    ) 
```

## Build experimental networks

The second step is to build up to three experimental networks, based on 
spectral similarity, correlation, and mass difference. We build
the experimental networks using the `buildExpNet` function, which has up to 
7 input parameters:

1. `inputData`. List returned by the `loadInputData` function.
2. `net2Build`. List of experimental networks to build, according to the 
   following options: 
     * *"all"* generates 3 experimental networks: mass difference, correlation,
       and spectral similarity,
     * *"m"* builds the mass difference network,
     * *"s"* builds the spectral similarity network,
     * *"c"* builds the correlation network.
   It is to note that combinations of "m", "s", and "c" are possible,
   writing them separated by commas, e.g., c("m", "c") would generate the mass 
   difference and correlation networks. The default value is "all".
3. `directed`. Boolean value (TRUE/FALSE). If TRUE, all the experimental 
   networks will be directed, and undirected otherwise. The default value is 
   FALSE (i.e., undirected networks).
4. `ppmMass`. Allowed error for mass differences calculus. This parameter is 
   only needed if the mass difference network is to be built. The default value
   is 10.
5. `ppmSpec`. Relative allowed error for spectral similarity calculus. This
   parameters is only needed if the spectral similarity network is to be built. 
   The default value is 0.
6. `tol`. Absolute tolerance for spectral similarity calculus. This parameter 
   is only needed if the spectral similarity network is to be built. The  
   default value is 0.005. 
7. `corrModel`. Character vector containing the model(s) to be used for the 
   correlation calculus. There are 11 models available: "lasso", "randomForest", 
   "clr", "aracne", "pearson", "pearson_partial", "pearson_semipartial", 
   "spearman", "spearman_partial", "spearman_semipartial", and "bayes". This 
   parameter is only needed if the correlation network is to be built. The 
   default value is "pearson_partial".
8. `corrThresh`. Floating point number indicating the correlation threshold to 
   consider that two features are correlated. It is only needed if the 
   correlation network is to be built. The default value is 0.25 (i.e., at 
   least 25% of correlation between the abundance values).

The output of the `buildExpNet` function is a list of experimental networks as 
igraph objects.

```{r bildNetworks}
expNetworks <-
  buildExpNet(
    inputData, 
    net2Build = "all", 
    directed = FALSE, 
    ppmMass = 10, 
    ppmSpec = 0,
    tol = 0.005, 
#    corrModel = "pearson_partial",
    corrModel = "pearson",
    corrThresh = 0.25
    )

```


## Map identified metabolites to the GSMN 

The third and last step to finish building our multi-layer network is to 
connect the GSMN to the experimental networks that we just created. In
order to do so, some of the metabolites from the peak list have to be manually
identified (i.e., their ChEBI id must be known). Considering the possibility 
of a metabolite to not be present in the GSMN (i.e., to not participate in 
any know reaction of a given GMSN), it is important to use tools such  
as `Metabolomics2Network` (see 
https://forgemia.inra.fr/metexplore/metabolomics2network) to be able to map
all of our identified metabolites to the GSMN. In particular, 
`Metabolomics2Network` uses the ChEBI ontology to locate any ChEBI id (from
the list of identified compounds) and it gives as result the ChEBI id of the 
nearest metabolite that is present in the GSMN, as well as the distance between 
them. We executed `Metabolomics2Network` with the files in 
`extdata/MTBLS1586/dataForMetabolomics2Networks`, and obtained the file 
`Result_MTBLS1586_LC-MS_positive_reverse-phase_metabolite_profiling_v2_maf.txt` 
as output. This file contains 12 columns, but we will focus on the first 5:
1. `metabolite name`. Name of our metabolites, as defined in the list of 
identified metabolites (`id` column from the file 
`IdentifiedMet_MTBLS1586_LC-MS_positive_reverse-phase_metabolite_profiling_v2_maf.tsv`)
2. `mapped on id`. Id of the node from the GSMN to which the metabolite was 
mapped (`ID` column from the file `WormJamMetabolites.tsv`). 
3. `mapping type`. Either `exact multimapping` or `chebi class mapping`, 
depending on which type we selected when running `Metabolomics2Network`.
4. `distance`. Distance in the ontology between the original metabolite and the 
metabolite to which it was mapped.
5. `chebi`. ChEBI id of the metabolite to which the original metabolite was
mapped.


```{r multilayer}
mappingF <- 
  system.file(
    paste0(path, "Metabolomics2NetworksData/Result_", exp, "_v2_maf.txt"), 
    package = "MetClassNetR"
    )

multiLayer <- makeMultiLayer(inputData, expNetworks, mappingF)

```

# Analyzing the multi-layer network

We will now proceed to analyze the interconnection level between the 
experimental layers and the GSMN of the multi-layer network. For that, we will 
calculate some basic stats, using the `calculateMultiLayerStats` function.


```{r multilayerStats}

```

