---
title: "MultiLayer"
author: "Elva Novoa"
date: '2022-06-08'
output: pdf_document
---

```{r setup, message=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(MetClassNetR)
library(MsCoreUtils)
library(tidyverse)
library(dplyr)
library(QFeatures)
```

# Buildig a multi-layer network

This vignette generates up to three experimental networks and connects them 
to a Genome-Scale Metabolic Network (GSMN) using the ChEBI ontology tree 
(`Metabolomics2Network` Python package). If an exact match if found, the 
distance between the metabolites is zero, and it can be higher or lower than 
zero, depending if the metabolite is mapped to a more general metabolite 
(parent class) or to a more specific metabolite (child).

Please note that you must have Python installed, and also the 
following packages: 
 - `Metabolomics2Network` 
 (download it from https://forgemia.inra.fr/metexplore/metabolomics2network)
 - `libchebipy` 
 - `urllib3`
 - `Sphinx`
 - `sphinxcontrib-napoleon`


## Load input data 

The first step in this workflow is to load the input data, using the 
`loadInputData` function, which has up to 11 input parameters:

1.  `peakListF`. Path to the TSV file containing the peak list (one peak per 
    row) in a MetaboLights-like format. The first row is the header (i.e., the 
    list of columns' names). The file should contain at least 3 columns: 
    "database_identifier" (ChEBI),  "mass_to_charge", and "retention_time". It 
    is to note that these column names are fixed. The TSV file can also contain
    intensity (or abundance) values. In this case, the column names are free 
    (e.g., can be named after the samples), but no blank spaces are allowed and 
    the first character must be a letter. In addition, all the abundances must 
    be placed at the end of the table, i.e., in the last columns. 
2.  `intCol`. Number of the first column containing the intensities. The 
    default value is 23, as in all datasets available in MetaboLights 
    (https://www.ebi.ac.uk/metabolights/).
3.  `transF`. (Optional) Path to the CSV file containing the transformation 
    list. It must have at  least the columns "name", "formula", and "mass". 
    This file is needed if the mass difference network is to be built.
4.  `spectraF`. (Optional) Path to the MSMS data in MGF format, if available.
5.  `gsmnF`. Path to the compound graph in GML format, as generated by Met4J 
    (https://forgemia.inra.fr/metexplore/met4j). The compound graphs of some
    organisms are available in the data folder.
6.  `spectraSS`. (Optional) Reduces the spectral dataset to the selected
    sample size to speed up the generation of the report when testing the 
    MetClassNetR package.
7.  `resPath`. Path to the folder where the results will be stored.
8.  `met2NetDir`. Path to the directory where the Python package
    Metabolomics2Network is. 
9.  `configF`. Path to the file that contains the column names (i.e., alias) of
    the identMetF file and the information they contain, such as name, chebi, 
    formula, etc. See an example in
    extdata/MTBLS1586/Metabolomics2NetworksData/JsonConf.txt.
    NOTE. This information will be used to do the metabolite mapping to the 
    GSMN (using metabolomics2Network)
10. `identMetF`. Path to the TSV file that contains the list of experimental
    features that were identified and that have a CHEBI id associated. The
    header of this file must match the aliases from the configuration file
    (configF)
11. `compF`. Path to the file that contains the list of compounds in the GSMN
    of the organism of interest. They must contain at least two columns: ID 
    and Chebi. An example can be found in
    extdata/MTBLS1586/Metabolomics2NetworksData/WormJamMet.tsv

The output of the `loadInputData` function is a named list containing all the  
data (i.e., peakList, spectra, transformations, and gsmn).

```{r loadData}
# load("../VariablesFromVignette.RData")
path <- "extdata/MTBLS1586/"
exp <- "MTBLS1586_LC-MS_positive_reverse-phase_metabolite_profiling"

inputData <- 
  loadInputData(
    peakListF = 
      system.file(
        paste0(path, "m_", exp, "_v2_maf.tsv"), 
        package = "MetClassNetR"
        ), 
    intCol = 23, 
    transF = 
      system.file(
        paste0(path, "transformations_MTBLS1586.csv"), 
        package = "MetClassNetR"
        ),
    spectraF = 
      system.file(
        paste0(path, "ms2_", exp, ".mgf"), 
        package = "MetClassNetR"
        ), 
    gsmnF = 
      system.file(
        paste0(path, "WormJam-GEM-20190101_L3_no-side_no-comp.gml"), 
        package = "MetClassNetR"
        ), 
    resPath = "~/MetClassNetR_MultiLayerNetwork/", 
    met2NetDir = 
      paste0(
        find.package("MetClassNetR"), 
        "/Python/metabolomics2network-master/"
        ),
    configF =  
      system.file(
        paste0(path, "Metabolomics2NetworksData/JsonConf.txt"), 
        package = "MetClassNetR"
        ),
    idenMetF =  
      system.file(
        paste0(
          path, 
          "Metabolomics2NetworksData/IdentifiedMet_", 
          exp, 
          "_v2_maf.tsv"
          ), 
        package = "MetClassNetR"
        ),
    compF = 
      system.file(
        paste0(path, "Metabolomics2NetworksData/WormJamMet.tsv"), 
        package = "MetClassNetR"
        ), 
    spectraSS = 50
    ) 

```

## Build experimental networks

The second step is to build up to three experimental networks, based on 
spectral similarity, correlation, and mass difference. We build
the experimental networks using the `buildExpNet` function, which has up to 
7 input parameters:

1. `inputData`. List returned by the `loadInputData` function.
2. `net2Build`. List of experimental networks to build, according to the 
   following options: 
     * *"all"* generates 3 experimental networks: mass difference, correlation,
       and spectral similarity,
     * *"m"* builds the mass difference network,
     * *"s"* builds the spectral similarity network,
     * *"c"* builds the correlation network.
   It is to note that combinations of "m", "s", and "c" are possible,
   writing them separated by commas, e.g., c("m", "c") would generate the mass 
   difference and correlation networks. The default value is "all".
3. `directed`. Boolean value (TRUE/FALSE). If TRUE, all the experimental 
   networks will be directed, and undirected otherwise. The default value is 
   FALSE (i.e., undirected networks).
4. `ppmMass`. Allowed error for mass differences calculus. This parameter is 
   only needed if the mass difference network is to be built. The default value
   is 10.
5. `ppmSpec`. Relative allowed error for spectral similarity calculus. This
   parameters is only needed if the spectral similarity network is to be built. 
   The default value is 0.
6. `tol`. Absolute tolerance for spectral similarity calculus. This parameter 
   is only needed if the spectral similarity network is to be built. The  
   default value is 0.005. 
7. `corrModel`. Character vector containing the model(s) to be used for the 
   correlation calculus. There are 11 models available: "lasso", "randomForest", 
   "clr", "aracne", "pearson", "pearson_partial", "pearson_semipartial", 
   "spearman", "spearman_partial", "spearman_semipartial", and "bayes". This 
   parameter is only needed if the correlation network is to be built. The 
   default value is "pearson_partial".
8. `corrThresh`. Floating point number indicating the correlation threshold to 
   consider that two features are correlated. It is only needed if the 
   correlation network is to be built. The default value is 0.25 (i.e., at 
   least 25% of correlation between the abundance values).

The output of the `buildExpNet` function is a list of experimental networks as 
igraph objects.

```{r buildNetworks}
expNetworks <-
  buildExpNet(
    inputData, 
    net2Build = "all", 
    directed = FALSE, 
    ppmMass = 10, 
    ppmSpec = 0,
    tol = 0.005, 
#    corrModel = "pearson_partial",
    corrModel = "pearson",
    corrThresh = 0.25
    )

```


## Map identified metabolites to the GSMN 

The third step is to map the manually identified features to the corresponding 
metabolites in the GSMN, using the ChEBI id of such features. Notably, although
it is possible to do exact matching and potentially have a low covering (i.e., 
to have very few matches since not all the metabolites participate in known
chemical reactions of a GSMN), we could also use ontologies (such as ChEBI) and 
maximize the covering. The Python tool `Metabolomics2Network` (see 
https://forgemia.inra.fr/metexplore/metabolomics2network) uses the ChEBI 
ontology to localize a ChEBI id from the list of identified compounds, and it 
gives as result the ChEBI id of the nearest metabolite that is present in the 
GSMN, as well as the distance between them. 
In order to run `Metabolomics2Network`, we need to call the 
`mapMetToGSMN` function and pass the `inputData` object as input
parameter. We can also choose the name of the resulting mappings file 
(`resFile`), which per default is "Res_Met2Net_MappedMet.txt". 
Such restulting file contains 12 columns, but we will focus on the first 5:
1. `metabolite name`. Name of our metabolites, as defined in the list of 
identified metabolites (`id` column from the file 
`IdentifiedMet_MTBLS1586_LC-MS_positive_reverse-phase_metabolite_profiling_v2_maf.tsv`)
2. `mapped on id`. Id of the node from the GSMN to which the metabolite was 
mapped (`ID` column from the file `WormJamMet.tsv`). 
3. `mapping type`. Either `exact multimapping` or `chebi class mapping`, 
depending on which type we selected when running `Metabolomics2Network`. Per 
default, it is `chebi class mapping`.
4. `distance`. Distance in the ontology between the original metabolite and the 
metabolite to which it was mapped.
5. `chebi`. ChEBI id of the metabolite to which the original metabolite was
mapped.

```{r mapping}
resFile <- "Res_Met2Net_MappedMet.txt"

mapMetToGSMN(inputData, resFile)
```

Finally, we are ready to finish building the multi-layer network, joining the 
experimental networks with the GSMN, thanks to the mappings we just obtained. 
To this end, we call the `makeMultiLayer` function with the `inputData` object,
the experimental networks (stored in `expNetworks`), and the name of the file 
that contains the mappings. 

In order to visualize and/or save the multi-layer network as two files: one
containing the list of edges and another one with the list of nodes, we call 
the `writeMultiLayer` function with the `inputData` and `multiLayer` objects, 
and a boolean value for the parameter `visualize` that should be `TRUE` if 
the multi-layer network is to be visualized in Cytoscape or `FALSE` otherwise. 
Please be aware that Cytoscape should be open if `visualize == TRUE`.


```{r multiLayer}
mappingF <- paste0(inputData$resPath, resFile)

multiLayer <- makeMultiLayer(inputData, expNetworks, mappingF)

writeMultiLayer(inputData, multiLayer, visualize = FALSE)
```


# Analyzing the multi-layer network

As a final step, we will analyze the interconnection level between the 
experimental layers and the GSMN of the multi-layer network. For that, we will 
calculate some basic stats, using the `calculateMultiLayerStats` function, 
which generates some plots and stores them in the `resPath` directory (defined
in `inputData`.


```{r multiLayerStats}
calculateMultiLayerStats(multiLayer, inputData)
```

```{r}
sessionInfo()
```

