---
title: "MultiLayer"
author: "Elva Novoa"
date: '2022-09-07'
output: pdf_document
---

```{r setup, message=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(MetClassNetR)
library(MsCoreUtils)
library(tidyverse)
library(dplyr)
library(QFeatures)
```

# Buildig a multi-layer network for *C. elegans*

This vignette demonstrates on example data from *C. elegans* the use of MetClassNetR to generate a
multilayer network. 


Stepwise it is shown how three experimental networks are
build from experimental MS data, which is given in maf format. In a next step
the experimental networks are connected to the Genome-Scale Metabolic Network (GSMN) 
of *C. elegans*, published in WormJam, using the tool Metabolomics2Network 
(https://forgemia.inra.fr/metexplore/metabolomics2network). 
Metabolomics2Network is a Python package which aims to map the assigned ChEBI IDs 
from the experimental feature list to the ChEBI IDs of the GSMN metabolites based on connections 
within the ChEBI ontology (https://doi.org/10.1093/nar/gkv1031).
If an exact match is found, the reported distance between feature and metabolites is zero. It will be 
be larger and lower than zero, depending if the metabolite is mapped to a more general metabolite 
(parent class) or to a more specific metabolite (child), respectively.

Please note that Python is required as well as the 
following Python packages: 
 - `Metabolomics2Network` 
 - `libchebipy` 
 - `urllib3`
 - `Sphinx`
 - `sphinxcontrib-napoleon`

 


## Load input data 

The first step in this workflow is to load the input data, using the `loadInputData` function.

The output of the `loadInputData` function is a named list containing all the  
data (i.e., peakList, spectra, transformations, and gsmn).

```{r loadData}
# load("../VariablesFromVignette.RData")
path <- "extdata/MTBLS1586/"
exp <- "MTBLS1586_LC-MS_positive_reverse-phase_metabolite_profiling"

inputData <- 
  loadInputData(
    peakListF = 
      system.file(
        paste0(path, "m_", exp, "_v2_maf.tsv"), 
        package = "MetClassNetR"
        ), 
    intCol = 23, 
    transF = 
      system.file(
        paste0(path, "transformations_MTBLS1586.csv"), 
        package = "MetClassNetR"
        ),
    spectraF = 
      system.file(
        paste0(path, "ms2_", exp, ".mgf"), 
        package = "MetClassNetR"
        ), 
    gsmnF = 
      system.file(
        paste0(path, "WormJam-GEM-20190101_L3_no-side_no-comp.gml"), 
        package = "MetClassNetR"
        ),  
    resPath = "~/MetClassNetR_MultiLayerNetwork/", 
    met2NetDir = 
      paste0(
        find.package("MetClassNetR"), 
        "/Python/metabolomics2network-master/"
        ),
    configF =  
      system.file(
        paste0(path, "Metabolomics2NetworksData/JsonConf.txt"), 
        package = "MetClassNetR"
        ),
    idenMetF =  
      system.file(
        paste0(
          path, 
          "Metabolomics2NetworksData/IdentifiedMet_", 
          exp, 
          "_v2_maf.tsv"
          ), 
        package = "MetClassNetR"
        ),
    metF = 
      system.file(
        paste0(path, "Metabolomics2NetworksData/WormJamMetWithMasses.tsv"), 
        package = "MetClassNetR"
        ), 
    spectraSS = 50,
    cleanMetF = FALSE
    ) 

```

## Build experimental networks

The second step is to build up to three experimental networks, based on 
spectral similarity, correlation, and mass difference. We build
the experimental networks using the `buildExpNet` function. This will
take some minutes depending on your system.

The output of the `buildExpNet` function is a list of experimental networks as 
igraph objects.

```{r buildNetworks}
expNetworks <-
  buildExpNet(
    inputData, 
    net2Build = "all", 
    directed = FALSE, 
    ppmMass = 10, 
    ppmSpec = 0,
    tol = 0.005, 
#    corrModel = "pearson_partial",
    corrModel = "pearson",
    corrThresh = 0.25
    )

```


## Map identified metabolites to the GSMN 

The third step is to map the manually identified features to the corresponding 
metabolites in the GSMN, using the ChEBI id of such features. Notably, although
it is possible to do exact matching and potentially have a low covering (i.e., 
to have very few matches since not all the metabolites participate in known
chemical reactions of a GSMN), we could also use ontologies (such as ChEBI) and 
maximize the covering. 

```{r mapping}

## Metabolomics2Network
resFile <- "Res_Met2Net_MappedMet.txt"

mapMetToGSMN(inputData, resFile, method="metabolomics2network")
```

Finally, we are ready to finish building the multi-layer network, joining the 
experimental networks with the GSMN, thanks to the mappings we just obtained. 
To this end, we call the `makeMultiLayer` function with the `inputData` object,
the experimental networks (stored in `expNetworks`), and the path to the folder 
that contains the mappings, which is called `GMSNMappings`, and it is located
inside `inpuData$resPath`. 

In order to visualize and/or save the multi-layer network as two files: one
containing the list of edges and another one with the list of nodes, we call 
the `writeMultiLayer` function with the `inputData` and `multiLayer` objects, 
and a boolean value for the parameter `visualize` that should be `TRUE` if 
the multi-layer network is to be visualized in Cytoscape or `FALSE` otherwise. 
Please be aware that Cytoscape should be open if `visualize == TRUE`.


```{r multiLayer}
pathToMappings <- paste0(inputData$resPath, "GSMNMappings/")

multiLayer <- makeMultiLayer(inputData, expNetworks, pathToMappings)

writeMultiLayer(inputData, multiLayer, visualize = FALSE)
```


# Analyzing the multi-layer network

As a final step, we will analyze the interconnection level between the 
experimental layers and the GSMN of the multi-layer network. For that, we will 
calculate some basic stats, using the `calculateMultiLayerStats` function, 
which generates some plots and stores them in the `resPath` directory (defined
in `inputData`.


```{r multiLayerStats}
calculateMultiLayerStats(multiLayer, inputData)
```

```{r}
sessionInfo()
```

