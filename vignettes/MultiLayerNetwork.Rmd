---
title: "MultiLayer"
author: "Elva Novoa"
date: '2022-09-07'
output: pdf_document
---

```{r setup, message=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(MetClassNetR)
library(MsCoreUtils)
library(tidyverse)
library(dplyr)
library(QFeatures)
```

# Buildig a multi-layer network

This vignette generates up to three experimental networks and connects them 
to a Genome-Scale Metabolic Network (GSMN) using the ChEBI ontology tree 
(`Metabolomics2Network` Python package). If an exact match is found, the 
distance between the metabolites is zero, and it can be higher or lower than 
zero, depending if the metabolite is mapped to a more general metabolite 
(parent class) or to a more specific metabolite (child).

Please note that you must have Python installed, and also the 
following packages: 
 - `Metabolomics2Network` 
 (download it from https://forgemia.inra.fr/metexplore/metabolomics2network)
 - `libchebipy` 
 - `urllib3`
 - `Sphinx`
 - `sphinxcontrib-napoleon`


## Load input data 

The first step in this workflow is to load the input data, using the 

`loadInputData` function, which has up to 11 input parameters:

1.  `peakListF`. Path to the TSV file containing the peak list (one peak per 
    row) in a MetaboLights-like format. The first row is the header (i.e., the 
    list of columns' names). The file should contain at least 3 columns: 
    "database_identifier" (ChEBI),  "mass_to_charge", and "retention_time". It 
    is to note that these column names are fixed. The TSV file can also contain
    intensity (or abundance) values. In this case, the column names are free 
    (e.g., can be named after the samples), but no blank spaces are allowed and 
    the first character must be a letter. In addition, all the abundances must 
    be placed at the end of the table, i.e., in the last columns. 
2.  `intCol`. Number of the first column containing the intensities. The 
    default value is 23, as in all datasets available in MetaboLights 
    (https://www.ebi.ac.uk/metabolights/).
3.  `transF`. (Optional) Path to the CSV file containing the transformation 
    list. It must have at  least the columns "name", "formula", and "mass". 
    This file is needed if the mass difference network is to be built.
4.  `spectraF`. (Optional) Path to the MSMS data in MGF format, if available.
5.  `gsmnF`. Path to the compound graph in GML format, as generated by Met4J 
    (https://forgemia.inra.fr/metexplore/met4j). The compound graphs of some
    organisms are available in the data folder.
6.  `spectraSS`. (Optional) Reduces the spectral dataset to the selected
    sample size to speed up the generation of the report when testing the 
    MetClassNetR package.
7.  `resPath`. Path to the folder where the results will be stored.
8.  `met2NetDir`. Path to the directory where the Python package
    Metabolomics2Network is. 
9.  `configF`. Path to the file that contains the column names (i.e., alias) of
    the identMetF file and the information they contain, such as name, chebi, 
    formula, etc. See an example in
    extdata/MTBLS1586/Metabolomics2NetworksData/JsonConf.txt.
    NOTE. This information will be used to do the metabolite mapping to the 
    GSMN (using metabolomics2Network)
10. `identMetF`. Path to the TSV file that contains the list of experimental
    features that were identified and that have a CHEBI id associated. The
    header of this file must match the aliases from the configuration file
    (configF)
11. `metF`. Path to the file that contains the list of compounds in the GSMN
    of the organism of interest. They must contain at least two columns: ID 
    and Chebi. An example can be found in
    extdata/MTBLS1586/Metabolomics2NetworksData/WormJamMet.tsv


The output of the `loadInputData` function is a named list containing all the  
data (i.e., peakList, spectra, transformations, and gsmn).

```{r loadData}
# load("../VariablesFromVignette.RData")
path <- "extdata/MTBLS1586/"
exp <- "MTBLS1586_LC-MS_positive_reverse-phase_metabolite_profiling"

inputData <- 
  loadInputData(
    peakListF = 
      system.file(
        paste0(path, "m_", exp, "_v2_maf.tsv"), 
        package = "MetClassNetR"
        ), 
    intCol = 23, 
    transF = 
      system.file(
        paste0(path, "transformations_MTBLS1586.csv"), 
        package = "MetClassNetR"
        ),
    spectraF = 
      system.file(
        paste0(path, "ms2_", exp, ".mgf"), 
        package = "MetClassNetR"
        ), 
    gsmnF = 
      system.file(
        paste0(path, "WormJam-GEM-20190101_L3_no-side_no-comp.gml"), 
        package = "MetClassNetR"
        ),  
    resPath = "~/MetClassNetR_MultiLayerNetwork/", 
    met2NetDir = 
      paste0(
        find.package("MetClassNetR"), 
        "/Python/metabolomics2network-master/"
        ),
    configF =  
      system.file(
        paste0(path, "Metabolomics2NetworksData/JsonConf.txt"), 
        package = "MetClassNetR"
        ),
    idenMetF =  
      system.file(
        paste0(
          path, 
          "Metabolomics2NetworksData/IdentifiedMet_", 
          exp, 
          "_v2_maf.tsv"
          ), 
        package = "MetClassNetR"
        ),
    metF = 
      system.file(
        paste0(path, "Metabolomics2NetworksData/WormJamMet_2019.tsv"), 
        package = "MetClassNetR"
        ), 
    spectraSS = 50,
    fixSpectra = TRUE,
    cleanMetF = FALSE
    ) 

```

## Build experimental networks

The second step is to build up to three experimental networks, based on 
spectral similarity, correlation, and mass difference. We build
the experimental networks using the `buildExpNet` function. This will
take some minutes depending on your system.

The output of the `buildExpNet` function is a list of experimental networks as 
igraph objects.

```{r buildNetworks}
expNetworks <-
  buildExpNet(
    inputData, 
    net2Build = "all", 
    directed = FALSE, 
    ppmMass = 10, 
    ppmSpec = 0,
    tol = 0.005, 
#    corrModel = "pearson_partial",
    corrModel = "pearson",
    corrThresh = 0.25
    )

```


## Map identified metabolites to the GSMN 

The third step is to map the manually identified features to the corresponding 
metabolites in the GSMN, using the ChEBI id of such features. Notably, although
it is possible to do exact matching and potentially have a low covering (i.e., 
to have very few matches since not all the metabolites participate in known
chemical reactions of a GSMN), we could also use ontologies (such as ChEBI) and 
maximize the covering. 

```{r mapping}

## Metabolomics2Network
resFile <- "Res_Met2Net_MappedMet.txt"

mapMetToGSMN(inputData, resFile, method="metabolomics2network")
```

Finally, we are ready to finish building the multi-layer network, joining the 
experimental networks with the GSMN, thanks to the mappings we just obtained. 
To this end, we call the `makeMultiLayer` function with the `inputData` object,
the experimental networks (stored in `expNetworks`), and the path to the folder 
that contains the mappings, which is called `GMSNMappings`, and it is located
inside `inpuData$resPath`. 

In order to visualize and/or save the multi-layer network as two files: one
containing the list of edges and another one with the list of nodes, we call 
the `writeMultiLayer` function with the `inputData` and `multiLayer` objects, 
and a boolean value for the parameter `visualize` that should be `TRUE` if 
the multi-layer network is to be visualized in Cytoscape or `FALSE` otherwise. 
Please be aware that Cytoscape should be open if `visualize == TRUE`.


```{r multiLayer}
pathToMappings <- paste0(inputData$resPath, "GSMNMappings/")

multiLayer <- makeMultiLayer(inputData, expNetworks, pathToMappings)

writeMultiLayer(inputData, multiLayer, visualize = FALSE)
```


# Analyzing the multi-layer network

As a final step, we will analyze the interconnection level between the 
experimental layers and the GSMN of the multi-layer network. For that, we will 
calculate some basic stats, using the `calculateMultiLayerStats` function, 
which generates some plots and stores them in the `resPath` directory (defined
in `inputData`.


```{r multiLayerStats}
calculateMultiLayerStats(multiLayer, inputData)
```

```{r}
sessionInfo()
```

