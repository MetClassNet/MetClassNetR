---
title: "Description and usage of MetClassNetR: MTBLS1586"
output:
    BiocStyle::html_document:
        toc_float: true
vignette: >
    %\VignetteIndexEntry{Description and usage of Description and usage of genedataRutils}
    %\VignetteEngine{knitr::rmarkdown}
    %\VignetteEncoding{UTF-8}
    %\VignettePackage{Spectra}
    %\VignetteDepends{Spectra,BiocStyle}
---

```{r style, echo = FALSE, results = 'asis', message=FALSE}
BiocStyle::markdown()
```

```{r, echo = FALSE, message = FALSE}
library(BiocStyle)
```

# Introduction

XXX (Description of MTBLS1586)

# Setup

## Load required libries

<code>MetClassNetR</code> integrates functions from different libraries.
Install current version of <code>MetClassNetR</code> and additional <code>MetNet</code> functions from developmental branches. After Installation re-load R and load required libraries.

```{r libraries, message=FALSE, warning=FALSE}
# installation of additional packages
#devtools::install_github("MetClassNet/MetNet", ref = "devel_Liesa") # note: Re-load R studio after installation
 #devtools::install_github("MetClassNet/MetClassNetR", ref = "devel_liesa") # note: Re-load R studio after installation

# load required libraries
library(tidyverse)
library(MetNet)
library(MetClassNetR)
library(QFeatures)
library(Spectra)
library(MsCoreUtils)
library(MsBackendMgf)
library(igraph)
library(tibble)
library(visNetwork) # for visNetwork() and friends
library(networkD3)  # for saveNetwork()
```

## Reading of MS1 data

MS1 data is read from Metabolights MAF or mzTab-M files into a <code>QFeatures</code>
object. Information about the mass-to-charge (mz) ratio and retention times (RT) were extracted from the MAF/ mzTab-M file and stored into the <code>QFeatures</code>-object. The data from positive and negative ionization mode are stored in two different <code>QFeatures</code>-objects. 

```{r ms1, message=FALSE}
# Metabolights MAF files
pos_maf <- system.file("extdata/MTBLS1586/m_MTBLS1586_LC-MS_positive_reverse-phase_metabolite_profiling_v2_maf.tsv", package = "MetClassNetR")
neg_maf <- system.file("extdata/MTBLS1586/m_MTBLS1586_LC-MS_positive_reverse-phase_metabolite_profiling_v2_maf.tsv", package = "MetClassNetR")

# create QFeature object
mtbls1586_qf_pos <- readMaf(file(pos_maf),
                                  ecol = 23:64,
                                  fnames = 22,
                                  name = "mtbls1586_pos",
                                  sep = "\t")

mtbls1586_qf_neg <- readMaf(file(neg_maf),
                                  ecol = 23:64,
                                  fnames = 22,
                                  name = "mtbls1586_neg",
                                  sep = "\t")
```


## Reading of MS2 data

MS2 data is read from a .mgf or .msp file into a <code>Spectra</code> object.

```{r ms2, message=FALSE, warning=FALSE}
# get MS2 data in .mgf files
pos_mgf <- system.file("extdata/MTBLS1586/ms2_MTBLS1586_LC-MS_positive_reverse-phase_metabolite_profiling.mgf", package = "MetClassNetR")
neg_mgf <- system.file("extdata/MTBLS1586/ms2_MTBLS1586_LC-MS_negative_reverse-phase_metabolite_profiling.mgf", package = "MetClassNetR")

# load MS2 data 
ms2_spectra_pos <- Spectra::Spectra(pos_mgf,
                           source = MsBackendMgf(),
                           backend = MsBackendDataFrame())

ms2_spectra_neg <- Spectra::Spectra(neg_mgf,
                           source = MsBackendMgf(),
                           backend = MsBackendDataFrame())
```

## Sanity checks

check data (namespace of ids etc...)

```{r}
# check minimal requirements
checkQFeatures(mtbls1586_qf_neg)
checkQFeatures(mtbls1586_qf_pos)
checkSpectra(ms2_spectra_neg)
checkSpectra(ms2_spectra_pos)
```

<code>checkIDNamespace</code> sanity check will fail if Ids between <code>QFeatures</code> and <code>Spectra</code> are not matching.Therefore, MS2 spectra can be filled with empty spectra to have a complete list of spectra for all the features.

```{r}
# fill spectra
ms2_spectra_neg <- fillSpectra(mtbls1586_qf_neg, ms2_spectra_neg)
ms2_spectra_pos <- fillSpectra(mtbls1586_qf_pos, ms2_spectra_pos)

# check namespace 
checkIdNamespace(mtbls1586_qf_neg, ms2_spectra_neg)
checkIdNamespace(mtbls1586_qf_pos, ms2_spectra_pos)
```


## Reading of transformation file

The mass-difference network is calculated using the <code>MetNet</code> package. Here, all calculated mass-differences between all pairs of features are compared to a transformation-list, containing different biochemical reactions and their corresponding mass difference. Required columns are "group" and "mass". Additional columns as "formula" can be added.
The transformation-list needs to be provided by the user. An example can be found in the system files. 

```{r transformation}
transformations_file <- system.file("extdata/MTBLS1586/transformations_MTBLS1586.csv", package = "MetClassNetR")
transformations <- read_csv(transformations_file, col_names = TRUE) %>% as.data.frame()
transformations[1:5,]
```



## Quality check of input

ZZZ

## Setup for networks

The <code>master</code>-list will contain all types of experimental networks that have been created in this workflow. 

```{r}
master <- list()
```

# Analysis

## Mass difference Network
The mass-difference network is calculated using the <code>MetNet</code> package. All mass-differences between all pairs of features are calculated and are compared to the <code>transformation</code>-list. This <code>transformation</code>-list contains different biochemical reactions and their corresponding mass difference. Only if the mass-difference between two features matches to a mass-difference in the transformation file, within a certain <code>ppm</code>-range, it will be displayed. Different to the original <code>MetNet</code>-functions, not only the name of the mass-difference but also the value itself will be displayed as output adjacency matrix.
The adjacency matrix will be than transformed to a list using the <code>adjacency_list</code>. 

```{r mass_difference}
# Create mass difference network
massdiff <- qfeat_structural(x = mtbls1586_qf_pos,
                             assay_name = "mtbls1586_pos",
                             transformation = transformations,
                             ppm = 10)

# Create list of adjacency matrix
massdiff_l <- adjacency_list(x=massdiff, 
                             from = "structural")
massdiff_l[25:30,]
```

A summary of the current data-set on the present mass-difference distribution is provided using the <code>summary_mz</code>-function. This function stores the summary as data.frame, which is also plotted. Depending on the size of the data, it might be useful to <code>filter</code> the number of determined mass-differences, e.g. by 1000 counts.

```{r}
# Summary of the list
sum_mz <- summary_mz(adjacency_list = massdiff_l)

# for big data: filter for counts higher 1000
sum_mz_f <- summary_mz(adjacency_list = massdiff_l,
                     filter = 1000)

# append mass difference network
master <- c(master, massdiff)

```


## Add manual annotatation 
A <code>QFeatures</code>-object stores various information on LC-MS/MS data. Also, annotations and possible database identifiers are present in a <code>QFeatures</code>-object. In order to add the annotations to the adjacency-list, <code>qfeat_annotation</code> is applied. It extracts the annotations, if any present, and adds them to the desired adjacency-list, for example the list from the mass-difference network. In order to check if the annotations match the mass-difference, a filter is applied so that only features remains that have annotations in both features. 

```{r manual_annotation}
# Add manual annotations to mass-difference adjacency list
name_l <- qfeat_annotation(x = mtbls1586_qf_pos, assay_name = "mtbls1586_pos", list = massdiff_l)

# Filter for manual annotations
annotationFiltered <- filter(name_l, is.na(name_l$Var1_annotation) == F, is.na(name_l$Var2_annotation) == F, name_l$Var1_annotation != "", name_l$Var2_annotation != "")
annotationFiltered[25:30,]

```


## Correlation network

Correlation networks will be calculated using functionality from the <code>MetNet</code> package. <code>qfeat_statistical</code> uses the <code>QFeatures</code>-Object as input and extracts the feature intensity in order to calculate correlations from the <code>statistical</code>-funtcion from <code>MetNet</code>. <code>MetNet</code> implemented various models that can be applied to calculate correlations, e.g. pearson, spearman, partial-pearson, and many more which might also be selected. After generating the correlation adjacency-matrix, it will also be transformed to a list. 

```{r correlation, warning=FALSE, error=FALSE}
# Correlation network using pearson and spearman correlation
pears_corr <- qfeat_statistical(x = mtbls1586_qf_pos,
                             assay_name = "mtbls1586_pos", 
                                model = c("pearson"))

source("vignette_helper.R") ## Overwrite threshhold()
pears_threshold <- threshold(statistical = pears_corr,
                             type = "threshold",
                             args = list("pearson" = 0.95, threshold = 1))
pears_threshold_l <- adjacency_list(x = pears_threshold,
                                    from = "statistical")
#exportNet2gml(x = pears_threshold_l, file = "pears_treshold")

```

Compared to the original <code>MetNet</code> package, additional functionality have been added to calculate also negative correlation values for pearson and spearman correlations. Moreover, the corresponding p-value will be calculated and displayed in the adjacency-list. 

```{r, warning=FALSE, error=FALSE}
# Correlation network using pearson and spearman correlation
# Positive, negative and p values are displayed
pears_corr_p <- qfeat_statistical(x = mtbls1586_qf_pos,
                             assay_name = "mtbls1586_pos",
                                model = c("pearson"),
                                p = TRUE)
pears_p_l <- adjacency_list(x = pears_corr_p,
                            from = "statistical")
pears_p_l[25:30,]

master <- c(master, pears_corr_p)

```

## Homologue Series

ABC


```{r homolseries}
library(nontarget)
library(igraph)

homol <- qfeat_homol(x = mtbls1586_qf_pos,
                             assay_name = "mtbls1586_pos",
                      elements=c("C","H","O"), use_C=TRUE,
                      minmz=5, 	maxmz=50,
                      minrt=5,  maxrt=60,
                      ppm=TRUE,
                      mztol=5,  rttol=5,
                      minlength=4,
                      mzfilter=FALSE,
                      spar=.45, 	R2=.98,
                      plotit=FALSE)
```


## MS2 similarity network

Spectral similarity network is created using some example spectra.

```{r ms2_network}
# costum matching function
#specNrow <-  function(x, y, ...) nrow(x)

# this is work around until Spectra is getting fixed
mydotproduct <- function(x, y, type = NA, ...) MsCoreUtils::ndotproduct(x, y, ...)

# test with some example spectra
ms2_similarity <- spec_molNetwork(ms2_spectra_pos[1:50],
                                  methods = "mydotproduct",
                                  tolerance = 0.005,
                                  type = "inner")

ms2_similarity_l <- spec_adjacency_list(ms2_similarity)

```


# Export networks to gml format 

Created networks are exported and saved as .gml file in the current working-directory. Feature Ids will be stored as additional name in node attributes. All the other information from the adjacency-lists will be stores as edge-attributes. It might also be defined which columns of the adjacency-list should be stored, by using the <code>select</code> option in the <code>exportNet2gml</code>-function.

```{r export2gml, eval=TRUE}
## does not work yet
exportNet2gml(x = massdiff_l, file = "mzdiff")

## Correlation network to gml (pearson, whithout p values)
exportNet2gml(x = pears_threshold_l, file = "pears")

## Spectral similarity network2gml
exportNet2gml(x = ms2_similarity_l, file = "similarity")

```

Additionally, attributes may be exported as .gml attribute-file using <code>exportAttributes2gml</code>. Edge attributes are prepared by merging the adjacency-lists from mass-difference and correlation-networks. Node attributes are generated by extraction additional information as annotation, mz, and RT values from the <code>QFeatures</code>-object. 

```{r, eval=FALSE}
# Create and export attribute file 
attributes <- merge(pears_p_l, massdiff_l, by = c("Var1", "Var2"))

  feat_names <- as.data.frame(rowData(mtbls1586_qf_pos[["mtbls1586_pos"]]))
  feat_names <- feat_names[,c("metabolite_identification", "mz", "rtime")]
  colnames(feat_names) <- c("manualAnnotation", "mz", "RT")

  
exportAttributes2gml(attributes, file = "attributes_mtbls1586_pos", names = feat_names)

```

Export of homologous series
```{r graph_export}
## Does not work yet?? 
el <- as_tibble(homol[["Peaks in homologue series"]]) %>%
    filter(`to ID` != "0") %>% select (c("peak ID", "to ID",
                                         "m/z increment", "RT increment"))

g <- el %>% select (c("peak ID", "to ID")) %>% as.matrix %>% graph_from_edgelist

## Write to File
write_graph(g, "homol.gml", "gml")

```




